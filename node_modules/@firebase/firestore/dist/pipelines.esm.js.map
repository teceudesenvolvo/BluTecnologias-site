{"version":3,"file":"pipelines.esm.js","sources":["../src/util/proto.ts","../src/lite-api/expressions.ts","../src/core/pipeline-util.ts","../src/lite-api/stage.ts","../src/lite-api/pipeline-source.ts","../src/lite-api/pipeline-result.ts","../src/util/pipeline_util.ts","../src/lite-api/pipeline.ts","../src/api/pipeline.ts","../src/api/pipeline_impl.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  ArrayValue as ProtoArrayValue,\n  Function as ProtoFunction,\n  LatLng as ProtoLatLng,\n  MapValue as ProtoMapValue,\n  Pipeline as ProtoPipeline,\n  Timestamp as ProtoTimestamp,\n  Value as ProtoValue\n} from '../protos/firestore_proto_api';\n\nimport { isPlainObject } from './input_validation';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nfunction isITimestamp(obj: any): obj is ProtoTimestamp {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'seconds' in obj &&\n    (obj.seconds === null ||\n      typeof obj.seconds === 'number' ||\n      typeof obj.seconds === 'string') &&\n    'nanos' in obj &&\n    (obj.nanos === null || typeof obj.nanos === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isILatLng(obj: any): obj is ProtoLatLng {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'latitude' in obj &&\n    (obj.latitude === null || typeof obj.latitude === 'number') &&\n    'longitude' in obj &&\n    (obj.longitude === null || typeof obj.longitude === 'number')\n  ) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIArrayValue(obj: any): obj is ProtoArrayValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('values' in obj && (obj.values === null || Array.isArray(obj.values))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIMapValue(obj: any): obj is ProtoMapValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('fields' in obj && (obj.fields === null || isPlainObject(obj.fields))) {\n    return true;\n  }\n\n  return false;\n}\nfunction isIFunction(obj: any): obj is ProtoFunction {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if (\n    'name' in obj &&\n    (obj.name === null || typeof obj.name === 'string') &&\n    'args' in obj &&\n    (obj.args === null || Array.isArray(obj.args))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isIPipeline(obj: any): obj is ProtoPipeline {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n  if ('stages' in obj && (obj.stages === null || Array.isArray(obj.stages))) {\n    return true;\n  }\n\n  return false;\n}\n\nexport function isFirestoreValue(obj: any): obj is ProtoValue {\n  if (typeof obj !== 'object' || obj === null) {\n    return false; // Must be a non-null object\n  }\n\n  // Check optional properties and their types\n  if (\n    ('nullValue' in obj &&\n      (obj.nullValue === null || obj.nullValue === 'NULL_VALUE')) ||\n    ('booleanValue' in obj &&\n      (obj.booleanValue === null || typeof obj.booleanValue === 'boolean')) ||\n    ('integerValue' in obj &&\n      (obj.integerValue === null ||\n        typeof obj.integerValue === 'number' ||\n        typeof obj.integerValue === 'string')) ||\n    ('doubleValue' in obj &&\n      (obj.doubleValue === null || typeof obj.doubleValue === 'number')) ||\n    ('timestampValue' in obj &&\n      (obj.timestampValue === null || isITimestamp(obj.timestampValue))) ||\n    ('stringValue' in obj &&\n      (obj.stringValue === null || typeof obj.stringValue === 'string')) ||\n    ('bytesValue' in obj &&\n      (obj.bytesValue === null || obj.bytesValue instanceof Uint8Array)) ||\n    ('referenceValue' in obj &&\n      (obj.referenceValue === null ||\n        typeof obj.referenceValue === 'string')) ||\n    ('geoPointValue' in obj &&\n      (obj.geoPointValue === null || isILatLng(obj.geoPointValue))) ||\n    ('arrayValue' in obj &&\n      (obj.arrayValue === null || isIArrayValue(obj.arrayValue))) ||\n    ('mapValue' in obj &&\n      (obj.mapValue === null || isIMapValue(obj.mapValue))) ||\n    ('fieldReferenceValue' in obj &&\n      (obj.fieldReferenceValue === null ||\n        typeof obj.fieldReferenceValue === 'string')) ||\n    ('functionValue' in obj &&\n      (obj.functionValue === null || isIFunction(obj.functionValue))) ||\n    ('pipelineValue' in obj &&\n      (obj.pipelineValue === null || isIPipeline(obj.pipelineValue)))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError } from '../api';\nimport { ParseContext } from '../api/parse_context';\nimport {\n  DOCUMENT_KEY_NAME,\n  FieldPath as InternalFieldPath\n} from '../model/path';\nimport { Value as ProtoValue } from '../protos/firestore_proto_api';\nimport {\n  JsonProtoSerializer,\n  ProtoValueSerializable,\n  toMapValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\nimport { isPlainObject } from '../util/input_validation';\nimport { isFirestoreValue } from '../util/proto';\nimport { isString } from '../util/types';\n\nimport { Bytes } from './bytes';\nimport { documentId as documentIdFieldPath, FieldPath } from './field_path';\nimport { vector } from './field_value_impl';\nimport { GeoPoint } from './geo_point';\nimport { DocumentReference } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument, parseData, UserData } from './user_data_reader';\nimport { VectorValue } from './vector_value';\n\n/**\n * @beta\n *\n * An enumeration of the different types of expressions.\n */\nexport type ExpressionType =\n  | 'Field'\n  | 'Constant'\n  | 'Function'\n  | 'AggregateFunction'\n  | 'ListOfExpressions'\n  | 'AliasedExpression';\n\n/**\n * @beta\n *\n * An enumeration of the different types generated by the Firestore backend.\n *\n * <ul>\n *  <li>Numerics evaluate directly to backend representation (`int64` or `float64`), not JS `number`.</li>\n *  <li>JavaScript `Date` and firestore `Timestamp` objects strictly evaluate to `'timestamp'`.</li>\n *  <li>Advanced configurations parsing backend types (such as `decimal128`, `max_key` or `min_key` from BSON) are also incorporated in this union string type. Note that `decimal128` is a backend-only numeric type that the JavaScript SDK cannot create natively, but can be evaluated in pipelines.</li>\n * </ul>\n */\nexport type Type =\n  | 'null'\n  | 'array'\n  | 'boolean'\n  | 'bytes'\n  | 'timestamp'\n  | 'geo_point'\n  | 'number'\n  | 'int32'\n  | 'int64'\n  | 'float64'\n  | 'decimal128'\n  | 'map'\n  | 'reference'\n  | 'string'\n  | 'vector'\n  | 'max_key'\n  | 'min_key'\n  | 'object_id'\n  | 'regex'\n  | 'request_timestamp';\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = _map(value as Record<string, unknown>, undefined);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nfunction vectorToExpr(value: VectorValue | number[] | Expression): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    return constant(value);\n  } else if (Array.isArray(value)) {\n    return constant(vector(value));\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nfunction fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n\n/**\n * @beta\n *\n * Represents an expression that can be evaluated to a value within the execution of a {@link\n * @firebase/firestore/pipelines#Pipeline}.\n *\n * Expressions are the building blocks for creating complex queries and transformations in\n * Firestore pipelines. They can represent:\n *\n * - **Field references:** Access values from document fields.\n * - **Literals:** Represent constant values (strings, numbers, booleans).\n * - **Function calls:** Apply functions to one or more expressions.\n *\n * The `Expression` class provides a fluent API for building expressions. You can chain together\n * method calls to create complex expressions.\n */\nexport abstract class Expression implements ProtoValueSerializable, UserData {\n  abstract readonly expressionType: ExpressionType;\n\n  abstract readonly _methodName?: string;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _toProto(serializer: JsonProtoSerializer): ProtoValue;\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  abstract _readUserData(context: ParseContext): void;\n\n  /**\n   * Creates an expression that adds this expression to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Add the value of the 'quantity' field and the 'reserve' field.\n   * field(\"quantity\").add(field(\"reserve\"));\n   * ```\n   *\n   * @param second - The expression or literal to add to this expression.\n   * @param others - Optional additional expressions or literals to add to this expression.\n   * @returns A new `Expression` representing the addition operation.\n   */\n  add(second: Expression | unknown): FunctionExpression {\n    return new FunctionExpression(\n      'add',\n      [this, valueToDefaultExpr(second)],\n      'add'\n    );\n  }\n\n  /**\n   * @beta\n   * Wraps the expression in a [BooleanExpression].\n   *\n   * @returns A [BooleanExpression] representing the same expression.\n   */\n  asBoolean(): BooleanExpression {\n    if (this instanceof BooleanExpression) {\n      return this;\n    } else if (this instanceof Constant) {\n      return new BooleanConstant(this);\n    } else if (this instanceof Field) {\n      return new BooleanField(this);\n    } else if (this instanceof FunctionExpression) {\n      return new BooleanFunctionExpression(this);\n    } else {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Conversion of type ${typeof this} to BooleanExpression not supported.`\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts another expression from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract the 'discount' field from the 'price' field\n   * field(\"price\").subtract(field(\"discount\"));\n   * ```\n   *\n   * @param subtrahend - The expression to subtract from this expression.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a constant value from this expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 20 from the value of the 'total' field\n   * field(\"total\").subtract(20);\n   * ```\n   *\n   * @param subtrahend - The constant value to subtract.\n   * @returns A new `Expression` representing the subtraction operation.\n   */\n  subtract(subtrahend: number): FunctionExpression;\n  subtract(subtrahend: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'subtract',\n      [this, valueToDefaultExpr(subtrahend)],\n      'subtract'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that multiplies this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Multiply the 'quantity' field by the 'price' field\n   * field(\"quantity\").multiply(field(\"price\"));\n   * ```\n   *\n   * @param second - The second expression or literal to multiply by.\n   * @param others - Optional additional expressions or literals to multiply by.\n   * @returns A new `Expression` representing the multiplication operation.\n   */\n  multiply(second: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'multiply',\n      [this, valueToDefaultExpr(second)],\n      'multiply'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'total' field by the 'count' field\n   * field(\"total\").divide(field(\"count\"));\n   * ```\n   *\n   * @param divisor - The expression to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that divides this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Divide the 'value' field by 10\n   * field(\"value\").divide(10);\n   * ```\n   *\n   * @param divisor - The constant value to divide by.\n   * @returns A new `Expression` representing the division operation.\n   */\n  divide(divisor: number): FunctionExpression;\n  divide(divisor: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'divide',\n      [this, valueToDefaultExpr(divisor)],\n      'divide'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by the 'divisor' field\n   * field(\"value\").mod(field(\"divisor\"));\n   * ```\n   *\n   * @param expression - The expression to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(expression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that calculates the modulo (remainder) of dividing this expression by a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the remainder of dividing the 'value' field by 10\n   * field(\"value\").mod(10);\n   * ```\n   *\n   * @param value - The constant value to divide by.\n   * @returns A new `Expression` representing the modulo operation.\n   */\n  mod(value: number): FunctionExpression;\n  mod(other: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'mod',\n      [this, valueToDefaultExpr(other)],\n      'mod'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is equal to 21\n   * field(\"age\").equal(21);\n   * ```\n   *\n   * @param expression - The expression to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'city' field is equal to \"London\"\n   * field(\"city\").equal(\"London\");\n   * ```\n   *\n   * @param value - The constant value to compare for equality.\n   * @returns A new `Expression` representing the equality comparison.\n   */\n  equal(value: unknown): BooleanExpression;\n  equal(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'equal',\n      [this, valueToDefaultExpr(other)],\n      'equal'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to \"completed\"\n   * field(\"status\").notEqual(\"completed\");\n   * ```\n   *\n   * @param expression - The expression to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'country' field is not equal to \"USA\"\n   * field(\"country\").notEqual(\"USA\");\n   * ```\n   *\n   * @param value - The constant value to compare for inequality.\n   * @returns A new `Expression` representing the inequality comparison.\n   */\n  notEqual(value: unknown): BooleanExpression;\n  notEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'not_equal',\n      [this, valueToDefaultExpr(other)],\n      'notEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is less than 'limit'\n   * field(\"age\").lessThan(field('limit'));\n   * ```\n   *\n   * @param experession - The expression to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(experession: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is less than 50\n   * field(\"price\").lessThan(50);\n   * ```\n   *\n   * @param value - The constant value to compare for less than.\n   * @returns A new `Expression` representing the less than comparison.\n   */\n  lessThan(value: unknown): BooleanExpression;\n  lessThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than',\n      [this, valueToDefaultExpr(other)],\n      'lessThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is less than or equal to 20\n   * field(\"quantity\").lessThan(constant(20));\n   * ```\n   *\n   * @param expression - The expression to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is less than or equal to a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is less than or equal to 70\n   * field(\"score\").lessThan(70);\n   * ```\n   *\n   * @param value - The constant value to compare for less than or equal to.\n   * @returns A new `Expression` representing the less than or equal to comparison.\n   */\n  lessThanOrEqual(value: unknown): BooleanExpression;\n  lessThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'less_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'lessThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'age' field is greater than the 'limit' field\n   * field(\"age\").greaterThan(field(\"limit\"));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is greater than 100\n   * field(\"price\").greaterThan(100);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than.\n   * @returns A new `Expression` representing the greater than comparison.\n   */\n  greaterThan(value: unknown): BooleanExpression;\n  greaterThan(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than',\n      [this, valueToDefaultExpr(other)],\n      'greaterThan'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to another\n   * expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'quantity' field is greater than or equal to field 'requirement' plus 1\n   * field(\"quantity\").greaterThanOrEqual(field('requirement').add(1));\n   * ```\n   *\n   * @param expression - The expression to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is greater than or equal to a constant\n   * value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'score' field is greater than or equal to 80\n   * field(\"score\").greaterThanOrEqual(80);\n   * ```\n   *\n   * @param value - The constant value to compare for greater than or equal to.\n   * @returns A new `Expression` representing the greater than or equal to comparison.\n   */\n  greaterThanOrEqual(value: unknown): BooleanExpression;\n  greaterThanOrEqual(other: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'greater_than_or_equal',\n      [this, valueToDefaultExpr(other)],\n      'greaterThanOrEqual'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates an array expression with one or more other arrays.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'items' array with another array field.\n   * field(\"items\").arrayConcat(field(\"otherItems\"));\n   * ```\n   * @param secondArray - Second array expression or array literal to concatenate.\n   * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n   * @returns A new `Expression` representing the concatenated array.\n   */\n  arrayConcat(\n    secondArray: Expression | unknown[],\n    ...otherArrays: Array<Expression | unknown[]>\n  ): FunctionExpression {\n    const elements = [secondArray, ...otherArrays];\n    const exprValues = elements.map(value => valueToDefaultExpr(value));\n    return new FunctionExpression(\n      'array_concat',\n      [this, ...exprValues],\n      'arrayConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific element.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'sizes' array contains the value from the 'selectedSize' field\n   * field(\"sizes\").arrayContains(field(\"selectedSize\"));\n   * ```\n   *\n   * @param expression - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(expression: Expression): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains a specific value.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'colors' array contains \"red\"\n   * field(\"colors\").arrayContains(\"red\");\n   * ```\n   *\n   * @param value - The element to search for in the array.\n   * @returns A new `Expression` representing the 'array_contains' comparison.\n   */\n  arrayContains(value: unknown): BooleanExpression;\n  arrayContains(element: unknown): BooleanExpression {\n    return new FunctionExpression(\n      'array_contains',\n      [this, valueToDefaultExpr(element)],\n      'arrayContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both the value in field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll([field(\"tag1\"), \"tag2\"]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains all the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'tags' array contains both of the values from field \"tag1\" and the literal value \"tag2\"\n   * field(\"tags\").arrayContainsAll(array([field(\"tag1\"), \"tag2\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_all' comparison.\n   */\n  arrayContainsAll(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAll(values: unknown[] | Expression): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAll')\n      : values;\n    return new FunctionExpression(\n      'array_contains_all',\n      [this, normalizedExpr],\n      'arrayContainsAll'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'categories' array contains either values from field \"cate1\" or \"cate2\"\n   * field(\"categories\").arrayContainsAny([field(\"cate1\"), field(\"cate2\")]);\n   * ```\n   *\n   * @param values - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if an array contains any of the specified elements.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'groups' array contains either the value from the 'userGroup' field\n   * // or the value \"guest\"\n   * field(\"groups\").arrayContainsAny(array([field(\"userGroup\"), \"guest\"]));\n   * ```\n   *\n   * @param arrayExpression - The elements to check for in the array.\n   * @returns A new `Expression` representing the 'array_contains_any' comparison.\n   */\n  arrayContainsAny(arrayExpression: Expression): BooleanExpression;\n  arrayContainsAny(\n    values: Array<unknown | Expression> | Expression\n  ): BooleanExpression {\n    const normalizedExpr = Array.isArray(values)\n      ? new ListOfExprs(values.map(valueToDefaultExpr), 'arrayContainsAny')\n      : values;\n    return new FunctionExpression(\n      'array_contains_any',\n      [this, normalizedExpr],\n      'arrayContainsAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses an array.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myArray' field.\n   * field(\"myArray\").arrayReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n   */\n  arrayReverse(): FunctionExpression {\n    return new FunctionExpression('array_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of an array.\n   *\n   * @example\n   * ```typescript\n   * // Get the number of items in the 'cart' array\n   * field(\"cart\").arrayLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the array.\n   */\n  arrayLength(): FunctionExpression {\n    return new FunctionExpression('array_length', [this], 'arrayLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(\"Electronics\", field(\"primaryType\"));\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n   * field(\"category\").equalAny(array([\"Electronics\", field(\"primaryType\")]));\n   * ```\n   *\n   * @param arrayExpression - An expression that evaluates to an array of values to check against.\n   * @returns A new `Expression` representing the 'IN' comparison.\n   */\n  equalAny(arrayExpression: Expression): BooleanExpression;\n  equalAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'equalAny')\n      : others;\n    return new FunctionExpression(\n      'equal_any',\n      [this, exprOthers],\n      'equalAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the provided values or\n   * expressions.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n   * field(\"status\").notEqualAny([\"pending\", field(\"rejectedStatus\")]);\n   * ```\n   *\n   * @param values - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(values: Array<Expression | unknown>): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if this expression is not equal to any of the values in the evaluated expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n   * field(\"status\").notEqualAny(field('rejectedStatuses'));\n   * ```\n   *\n   * @param arrayExpression - The values or expressions to check against.\n   * @returns A new `Expression` representing the 'notEqualAny' comparison.\n   */\n  notEqualAny(arrayExpression: Expression): BooleanExpression;\n  notEqualAny(others: unknown[] | Expression): BooleanExpression {\n    const exprOthers = Array.isArray(others)\n      ? new ListOfExprs(others.map(valueToDefaultExpr), 'notEqualAny')\n      : others;\n    return new FunctionExpression(\n      'not_equal_any',\n      [this, exprOthers],\n      'notEqualAny'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a field exists in the document.\n   *\n   * @example\n   * ```typescript\n   * // Check if the document has a field named \"phoneNumber\"\n   * field(\"phoneNumber\").exists();\n   * ```\n   *\n   * @returns A new `Expression` representing the 'exists' check.\n   */\n  exists(): BooleanExpression {\n    return new FunctionExpression('exists', [this], 'exists').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the character length of a string in UTF-8.\n   *\n   * @example\n   * ```typescript\n   * // Get the character length of the 'name' field in its UTF-8 form.\n   * field(\"name\").charLength();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string.\n   */\n  charLength(): FunctionExpression {\n    return new FunctionExpression('char_length', [this], 'charLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that performs a case-sensitive string comparison.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'title' field contains the word \"guide\" (case-sensitive)\n   * field(\"title\").like(\"%guide%\");\n   * ```\n   *\n   * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n   * @returns A new `Expression` representing the 'like' comparison.\n   */\n  like(pattern: Expression): BooleanExpression;\n  like(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'like',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'like'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\" (case-insensitive)\n   * field(\"description\").regexContains(\"(?i)example\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified regular expression as a\n   * substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the regular expression stored in field 'regex'\n   * field(\"description\").regexContains(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the search.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  regexContains(pattern: Expression): BooleanExpression;\n  regexContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the first substring of a string expression that matches\n   * a specified regular expression.\n   *\n   * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n   *\n   * @example\n   * ```typescript\n   * // Extract the domain from an email address\n   * field(\"email\").regexFind(\"@.+\")\n   * ```\n   *\n   * @param pattern - The regular expression to search for.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression find function.\n   */\n  regexFind(pattern: string): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the first substring of a string expression that matches\n   * a specified regular expression.\n   *\n   * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n   *\n   * @example\n   * ```typescript\n   * // Extract the domain from an email address\n   * field(\"email\").regexFind(field(\"domain\"))\n   * ```\n   *\n   * @param pattern - The regular expression to search for.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression find function.\n   */\n  regexFind(pattern: Expression): FunctionExpression;\n  regexFind(stringOrExpr: string | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'regex_find',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexFind'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that evaluates to a list of all substrings in this string expression that\n   * match a specified regular expression.\n   *\n   * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n   *\n   * @example\n   * ```typescript\n   * // Extract all hashtags from a post content field\n   * field(\"content\").regexFindAll(\"#[A-Za-z0-9_]+\")\n   * ```\n   *\n   * @param pattern - The regular expression to search for.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} that evaluates to an array of matched substrings.\n   */\n  regexFindAll(pattern: string): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that evaluates to a list of all substrings in this string expression that\n   * match a specified regular expression.\n   *\n   * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n   *\n   * @example\n   * ```typescript\n   * // Extract all names from a post content field\n   * field(\"content\").regexFindAll(field(\"names\"))\n   * ```\n   *\n   * @param pattern - The regular expression to search for.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} that evaluates to an array of matched substrings.\n   */\n  regexFindAll(pattern: Expression): FunctionExpression;\n  regexFindAll(stringOrExpr: string | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'regex_find_all',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexFindAll'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a valid email pattern\n   * field(\"email\").regexMatch(\"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string matches a specified regular expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'email' field matches a regular expression stored in field 'regex'\n   * field(\"email\").regexMatch(field(\"regex\"));\n   * ```\n   *\n   * @param pattern - The regular expression to use for the match.\n   * @returns A new `Expression` representing the regular expression match.\n   */\n  regexMatch(pattern: Expression): BooleanExpression;\n  regexMatch(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'regex_match',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'regexMatch'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains a specified substring.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains \"example\".\n   * field(\"description\").stringContains(\"example\");\n   * ```\n   *\n   * @param substring - The substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(substring: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string contains the string represented by another expression.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'description' field contains the value of the 'keyword' field.\n   * field(\"description\").stringContains(field(\"keyword\"));\n   * ```\n   *\n   * @param expr - The expression representing the substring to search for.\n   * @returns A new `Expression` representing the 'contains' comparison.\n   */\n  stringContains(expr: Expression): BooleanExpression;\n  stringContains(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'string_contains',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'stringContains'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'name' field starts with \"Mr.\"\n   * field(\"name\").startsWith(\"Mr.\");\n   * ```\n   *\n   * @param prefix - The prefix to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string starts with a given prefix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'fullName' field starts with the value of the 'firstName' field\n   * field(\"fullName\").startsWith(field(\"firstName\"));\n   * ```\n   *\n   * @param prefix - The prefix expression to check for.\n   * @returns A new `Expression` representing the 'starts with' comparison.\n   */\n  startsWith(prefix: Expression): BooleanExpression;\n  startsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'starts_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'startsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'filename' field ends with \".txt\"\n   * field(\"filename\").endsWith(\".txt\");\n   * ```\n   *\n   * @param suffix - The postfix to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: string): BooleanExpression;\n\n  /**\n   * @beta\n   * Creates an expression that checks if a string ends with a given postfix (represented as an\n   * expression).\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'url' field ends with the value of the 'extension' field\n   * field(\"url\").endsWith(field(\"extension\"));\n   * ```\n   *\n   * @param suffix - The postfix expression to check for.\n   * @returns A new `Expression` representing the 'ends with' comparison.\n   */\n  endsWith(suffix: Expression): BooleanExpression;\n  endsWith(stringOrExpr: string | Expression): BooleanExpression {\n    return new FunctionExpression(\n      'ends_with',\n      [this, valueToDefaultExpr(stringOrExpr)],\n      'endsWith'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to lowercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'name' field to lowercase\n   * field(\"name\").toLower();\n   * ```\n   *\n   * @returns A new `Expression` representing the lowercase string.\n   */\n  toLower(): FunctionExpression {\n    return new FunctionExpression('to_lower', [this], 'toLower');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts a string to uppercase.\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'title' field to uppercase\n   * field(\"title\").toUpper();\n   * ```\n   *\n   * @returns A new `Expression` representing the uppercase string.\n   */\n  toUpper(): FunctionExpression {\n    return new FunctionExpression('to_upper', [this], 'toUpper');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that removes leading and trailing characters from a string or byte array.\n   *\n   * @example\n   * ```typescript\n   * // Trim whitespace from the 'userInput' field\n   * field(\"userInput\").trim();\n   *\n   * // Trim quotes from the 'userInput' field\n   * field(\"userInput\").trim('\"');\n   * ```\n   * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n   * trimmed from the input. If not specified, then whitespace will be trimmed.\n   * @returns A new `Expression` representing the trimmed string or byte array.\n   */\n  trim(valueToTrim?: string | Expression | Bytes): FunctionExpression {\n    const args: Expression[] = [this];\n    if (valueToTrim) {\n      args.push(valueToDefaultExpr(valueToTrim));\n    }\n    return new FunctionExpression('trim', args, 'trim');\n  }\n\n  /**\n   * @beta\n   * Trims whitespace or a specified set of characters/bytes from the beginning of a string or byte array.\n   *\n   * @example\n   * ```typescript\n   * // Trim whitespace from the beginning of the 'userInput' field\n   * field(\"userInput\").ltrim();\n   *\n   * // Trim quotes from the beginning of the 'userInput' field\n   * field(\"userInput\").ltrim('\"');\n   * ```\n   *\n   * @param valueToTrim - Optional. A string or byte array containing the characters/bytes to trim.\n   * If not specified, whitespace will be trimmed.\n   * @returns A new `Expression` representing the trimmed string.\n   */\n  ltrim(valueToTrim?: string | Expression | Bytes): FunctionExpression {\n    const args: Expression[] = [this];\n    if (valueToTrim) {\n      args.push(valueToDefaultExpr(valueToTrim));\n    }\n    return new FunctionExpression('ltrim', args, 'ltrim');\n  }\n\n  /**\n   * @beta\n   * Trims whitespace or a specified set of characters/bytes from the end of a string or byte array.\n   *\n   * @example\n   * ```typescript\n   * // Trim whitespace from the end of the 'userInput' field\n   * field(\"userInput\").rtrim();\n   *\n   * // Trim quotes from the end of the 'userInput' field\n   * field(\"userInput\").rtrim('\"');\n   * ```\n   *\n   * @param valueToTrim - Optional. A string or byte array containing the characters/bytes to trim.\n   * If not specified, whitespace will be trimmed.\n   * @returns A new `Expression` representing the trimmed string or byte array.\n   */\n  rtrim(valueToTrim?: string | Expression | Bytes): FunctionExpression {\n    const args: Expression[] = [this];\n    if (valueToTrim) {\n      args.push(valueToDefaultExpr(valueToTrim));\n    }\n    return new FunctionExpression('rtrim', args, 'rtrim');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the data type of this expression's result, as a string.\n   *\n   * @remarks\n   * This is evaluated on the backend. This means:\n   * 1. Generic typed elements (like `array<string>`) evaluate strictly to the primitive `'array'`.\n   * 2. Any custom `FirestoreDataConverter` mappings are ignored.\n   * 3. For numeric values, the backend does not yield the JavaScript `\"number\"` type; it evaluates\n   *    precisely as `\"int64\"` or `\"float64\"`.\n   * 4. For date or timestamp objects, the backend evaluates to `\"timestamp\"`.\n   *\n   * @example\n   * ```typescript\n   * // Get the data type of the value in field 'title'\n   * field('title').type()\n   * ```\n   *\n   * @returns A new `Expression` representing the data type.\n   */\n  type(): FunctionExpression {\n    return new FunctionExpression('type', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that checks if the result of this expression is of the given type.\n   *\n   * @remarks Null or undefined fields evaluate to skip/error. Use `ifAbsent()` / `isAbsent()` to evaluate missing data.\n   *\n   * @example\n   * ```typescript\n   * // Check if the 'price' field is specifically an integer (not just 'number')\n   * field('price').isType('int64');\n   * ```\n   *\n   * @param type - The type to check for.\n   * @returns A new `BooleanExpression` that evaluates to true if the expression's result is of the given type, false otherwise.\n   */\n  isType(type: Type): BooleanExpression {\n    return new FunctionExpression(\n      'is_type',\n      [this, constant(type)],\n      'isType'\n    ).asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates string expressions together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n   * field(\"firstName\").stringConcat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param secondString - The additional expression or string literal to concatenate.\n   * @param otherStrings - Optional additional expressions or string literals to concatenate.\n   * @returns A new `Expression` representing the concatenated string.\n   */\n  stringConcat(\n    secondString: Expression | string,\n    ...otherStrings: Array<Expression | string>\n  ): FunctionExpression {\n    const elements = [secondString, ...otherStrings];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'string_concat',\n      [this, ...exprs],\n      'stringConcat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that finds the index of the first occurrence of a substring or byte sequence.\n   *\n   * @example\n   * ```typescript\n   * // Find the index of \"foo\" in the 'text' field\n   * field(\"text\").stringIndexOf(\"foo\");\n   * ```\n   *\n   * @param search - The substring or byte sequence to search for.\n   * @returns A new `Expression` representing the index of the first occurrence.\n   */\n  stringIndexOf(search: string | Expression | Bytes): FunctionExpression {\n    return new FunctionExpression(\n      'string_index_of',\n      [this, valueToDefaultExpr(search)],\n      'stringIndexOf'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that repeats a string or byte array a specified number of times.\n   *\n   * @example\n   * ```typescript\n   * // Repeat the 'label' field 3 times\n   * field(\"label\").stringRepeat(3);\n   * ```\n   *\n   * @param repetitions - The number of times to repeat the string or byte array.\n   * @returns A new `Expression` representing the repeated string or byte array.\n   */\n  stringRepeat(repetitions: number | Expression): FunctionExpression {\n    return new FunctionExpression(\n      'string_repeat',\n      [this, valueToDefaultExpr(repetitions)],\n      'stringRepeat'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that replaces all occurrences of a substring or byte sequence with a replacement.\n   *\n   * @example\n   * ```typescript\n   * // Replace all occurrences of \"foo\" with \"bar\" in the 'text' field\n   * field(\"text\").stringReplaceAll(\"foo\", \"bar\");\n   * ```\n   *\n   * @param find - The substring or byte sequence to search for.\n   * @param replacement - The replacement string or byte sequence.\n   * @returns A new `Expression` representing the string or byte array with replacements.\n   */\n  stringReplaceAll(\n    find: string | Expression | Bytes,\n    replacement: string | Expression | Bytes\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'string_replace_all',\n      [this, valueToDefaultExpr(find), valueToDefaultExpr(replacement)],\n      'stringReplaceAll'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that replaces the first occurrence of a substring or byte sequence with a replacement.\n   *\n   * @example\n   * ```typescript\n   * // Replace the first occurrence of \"foo\" with \"bar\" in the 'text' field\n   * field(\"text\").stringReplaceOne(\"foo\", \"bar\");\n   * ```\n   *\n   * @param find - The substring or byte sequence to search for.\n   * @param replacement - The replacement string or byte sequence.\n   * @returns A new `Expression` representing the string or byte array with the replacement.\n   */\n  stringReplaceOne(\n    find: string | Expression | Bytes,\n    replacement: string | Expression | Bytes\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'string_replace_one',\n      [this, valueToDefaultExpr(find), valueToDefaultExpr(replacement)],\n      'stringReplaceOne'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that concatenates expression results together.\n   *\n   * @example\n   * ```typescript\n   * // Combine the 'firstName', ' ', and 'lastName' fields into a single value.\n   * field(\"firstName\").concat(constant(\" \"), field(\"lastName\"));\n   * ```\n   *\n   * @param second - The additional expression or literal to concatenate.\n   * @param others - Optional additional expressions or literals to concatenate.\n   * @returns A new `Expression` representing the concatenated value.\n   */\n  concat(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const elements = [second, ...others];\n    const exprs = elements.map(valueToDefaultExpr);\n    return new FunctionExpression('concat', [this, ...exprs], 'concat');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses this string expression.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").reverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  reverse(): FunctionExpression {\n    return new FunctionExpression('reverse', [this], 'reverse');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of this string expression in bytes.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the length of the 'myString' field in bytes.\n   * field(\"myString\").byteLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n   */\n  byteLength(): FunctionExpression {\n    return new FunctionExpression('byte_length', [this], 'byteLength');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the ceiling of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the ceiling of the 'price' field.\n   * field(\"price\").ceil();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n   */\n  ceil(): FunctionExpression {\n    return new FunctionExpression('ceil', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the floor of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the floor of the 'price' field.\n   * field(\"price\").floor();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n   */\n  floor(): FunctionExpression {\n    return new FunctionExpression('floor', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the absolute value of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the absolute value of the 'price' field.\n   * field(\"price\").abs();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n   */\n  abs(): FunctionExpression {\n    return new FunctionExpression('abs', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes e to the power of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Compute e to the power of the 'value' field.\n   * field(\"value\").exp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n   */\n  exp(): FunctionExpression {\n    return new FunctionExpression('exp', [this]);\n  }\n\n  /**\n   * @beta\n   * Accesses a value from a map (object) field using the provided key.\n   *\n   * @example\n   * ```typescript\n   * // Get the 'city' value from the 'address' map field\n   * field(\"address\").mapGet(\"city\");\n   * ```\n   *\n   * @param subfield - The key to access in the map.\n   * @returns A new `Expression` representing the value associated with the given key in the map.\n   */\n  mapGet(subfield: string): FunctionExpression {\n    return new FunctionExpression(\n      'map_get',\n      [this, constant(subfield)],\n      'mapGet'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns a new map with the specified entries added or updated.\n   *\n   * @remarks\n   * Note that `mapSet` only performs shallow updates to the map. Setting a value to `null`\n   * will retain the key with a `null` value. To remove a key entirely, use `mapRemove`.\n   *\n   * @example\n   * ```typescript\n   * // Set the 'city' to \"San Francisco\" in the 'address' map\n   * field(\"address\").mapSet(\"city\", \"San Francisco\");\n   * ```\n   *\n   * @param key - The key to set. Must be a string or a constant string expression.\n   * @param value - The value to set.\n   * @param moreKeyValues - Additional key-value pairs to set.\n   * @returns A new `Expression` representing the map with the entries set.\n   */\n  mapSet(\n    key: string | Expression,\n    value: unknown,\n    ...moreKeyValues: unknown[]\n  ): FunctionExpression {\n    const args = [\n      this,\n      valueToDefaultExpr(key),\n      valueToDefaultExpr(value),\n      ...moreKeyValues.map(valueToDefaultExpr)\n    ];\n    return new FunctionExpression('map_set', args, 'mapSet');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the keys of a map.\n   *\n   * @remarks\n   * While the backend generally preserves insertion order, relying on the\n   * order of the output array is not guaranteed and should be avoided.\n   *\n   * @example\n   * ```typescript\n   * // Get the keys of the 'address' map\n   * field(\"address\").mapKeys();\n   * ```\n   *\n   * @returns A new `Expression` representing the keys of the map.\n   */\n  mapKeys(): FunctionExpression {\n    return new FunctionExpression('map_keys', [this], 'mapKeys');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the values of a map.\n   *\n   * @remarks\n   * While the backend generally preserves insertion order, relying on the\n   * order of the output array is not guaranteed and should be avoided.\n   *\n   * @example\n   * ```typescript\n   * // Get the values of the 'address' map\n   * field(\"address\").mapValues();\n   * ```\n   *\n   * @returns A new `Expression` representing the values of the map.\n   */\n  mapValues(): FunctionExpression {\n    return new FunctionExpression('map_values', [this], 'mapValues');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the entries of a map as an array of maps,\n   * where each map contains a `\"k\"` property for the key and a `\"v\"` property for the value.\n   * For example: `[{ k: \"key1\", v: \"value1\" }, ...]`.\n   *\n   * @example\n   * ```typescript\n   * // Get the entries of the 'address' map\n   * field(\"address\").mapEntries();\n   * ```\n   *\n   * @returns A new `Expression` representing the entries of the map.\n   */\n  mapEntries(): FunctionExpression {\n    return new FunctionExpression('map_entries', [this], 'mapEntries');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n   * expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the total number of products\n   * field(\"productId\").count().as(\"totalProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count' aggregation.\n   */\n  count(): AggregateFunction {\n    return AggregateFunction._create('count', [this], 'count');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the sum of a numeric field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total revenue from a set of orders\n   * field(\"orderAmount\").sum().as(\"totalRevenue\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'sum' aggregation.\n   */\n  sum(): AggregateFunction {\n    return AggregateFunction._create('sum', [this], 'sum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that calculates the average (mean) of a numeric field across multiple\n   * stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average age of users\n   * field(\"age\").average().as(\"averageAge\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'average' aggregation.\n   */\n  average(): AggregateFunction {\n    return AggregateFunction._create('average', [this], 'average');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the lowest price of all products\n   * field(\"price\").minimum().as(\"lowestPrice\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'minimum' aggregation.\n   */\n  minimum(): AggregateFunction {\n    return AggregateFunction._create('minimum', [this], 'minimum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the highest score in a leaderboard\n   * field(\"score\").maximum().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'maximum' aggregation.\n   */\n  maximum(): AggregateFunction {\n    return AggregateFunction._create('maximum', [this], 'maximum');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the first value of an expression across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the first value of the 'rating' field\n   * field(\"rating\").first().as(\"firstRating\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'first' aggregation.\n   */\n  first(): AggregateFunction {\n    return AggregateFunction._create('first', [this], 'first');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the last value of an expression across multiple stage inputs.\n   *\n   * @example\n   * ```typescript\n   * // Find the last value of the 'rating' field\n   * field(\"rating\").last().as(\"lastRating\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'last' aggregation.\n   */\n  last(): AggregateFunction {\n    return AggregateFunction._create('last', [this], 'last');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that collects all values of an expression across multiple stage inputs\n   * into an array.\n   *\n   * @remarks\n   * If the expression resolves to an absent value, it is converted to `null`.\n   * The order of elements in the output array is not stable and shouldn't be relied upon.\n   *\n   * @example\n   * ```typescript\n   * // Collect all tags from books into an array\n   * field(\"tags\").arrayAgg().as(\"allTags\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'array_agg' aggregation.\n   */\n  arrayAgg(): AggregateFunction {\n    return AggregateFunction._create('array_agg', [this], 'arrayAgg');\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that collects all distinct values of an expression across multiple stage\n   * inputs into an array.\n   *\n   * @remarks\n   * If the expression resolves to an absent value, it is converted to `null`.\n   * The order of elements in the output array is not stable and shouldn't be relied upon.\n   *\n   * @example\n   * ```typescript\n   * // Collect all distinct tags from books into an array\n   * field(\"tags\").arrayAggDistinct().as(\"allDistinctTags\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'array_agg_distinct' aggregation.\n   */\n  arrayAggDistinct(): AggregateFunction {\n    return AggregateFunction._create(\n      'array_agg_distinct',\n      [this],\n      'arrayAggDistinct'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that counts the number of distinct values of the expression or field.\n   *\n   * @example\n   * ```typescript\n   * // Count the distinct number of products\n   * field(\"productId\").countDistinct().as(\"distinctProducts\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n   */\n  countDistinct(): AggregateFunction {\n    return AggregateFunction._create('count_distinct', [this], 'countDistinct');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the larger value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the larger value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMaximum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n   */\n  logicalMaximum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'maximum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'logicalMaximum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the smaller value between this expression and another expression, based on Firestore's value type ordering.\n   *\n   * @example\n   * ```typescript\n   * // Returns the smaller value between the 'timestamp' field and the current timestamp.\n   * field(\"timestamp\").logicalMinimum(Function.currentTimestamp());\n   * ```\n   *\n   * @param second - The second expression or literal to compare with.\n   * @param others - Optional additional expressions or literals to compare with.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n   */\n  logicalMinimum(\n    second: Expression | unknown,\n    ...others: Array<Expression | unknown>\n  ): FunctionExpression {\n    const values = [second, ...others];\n    return new FunctionExpression(\n      'minimum',\n      [this, ...values.map(valueToDefaultExpr)],\n      'minimum'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length (number of dimensions) of this Firestore Vector expression.\n   *\n   * @example\n   * ```typescript\n   * // Get the vector length (dimension) of the field 'embedding'.\n   * field(\"embedding\").vectorLength();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the vector.\n   */\n  vectorLength(): FunctionExpression {\n    return new FunctionExpression('vector_length', [this], 'vectorLength');\n  }\n\n  /**\n   * @beta\n   * Calculates the cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n   * field(\"userVector\").cosineDistance(field(\"itemVector\"));\n   * ```\n   *\n   * @param vectorExpression - The other vector (represented as an Expression) to compare against.\n   * @returns A new `Expression` representing the cosine distance between the two vectors.\n   */\n  cosineDistance(vectorExpression: Expression): FunctionExpression;\n  /**\n   * @beta\n   * Calculates the Cosine distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Cosine distance between the 'location' field and a target location\n   * field(\"location\").cosineDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Cosine* distance between the two vectors.\n   */\n  cosineDistance(vector: VectorValue | number[]): FunctionExpression;\n  cosineDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'cosine_distance',\n      [this, vectorToExpr(other)],\n      'cosineDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct([0.5, 0.8, 0.2]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the dot product between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the dot product between a feature vector and a target vector\n   * field(\"features\").dotProduct(new VectorValue([0.5, 0.8, 0.2]));\n   * ```\n   *\n   * @param vector - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the dot product between the two vectors.\n   */\n  dotProduct(vector: VectorValue | number[]): FunctionExpression;\n  dotProduct(other: Expression | VectorValue | number[]): FunctionExpression {\n    return new FunctionExpression(\n      'dot_product',\n      [this, vectorToExpr(other)],\n      'dotProduct'\n    );\n  }\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance([37.7749, -122.4194]);\n   * ```\n   *\n   * @param vectorExpression - The other vector (as an array of numbers) to calculate with.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vectorExpression: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Calculates the Euclidean distance between two vectors.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the Euclidean distance between the 'location' field and a target location\n   * field(\"location\").euclideanDistance(new VectorValue([37.7749, -122.4194]));\n   * ```\n   *\n   * @param vector - The other vector (as a VectorValue) to compare against.\n   * @returns A new `Expression` representing the Euclidean distance between the two vectors.\n   */\n  euclideanDistance(vector: VectorValue | number[]): FunctionExpression;\n  euclideanDistance(\n    other: Expression | VectorValue | number[]\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'euclidean_distance',\n      [this, vectorToExpr(other)],\n      'euclideanDistance'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'microseconds' field as microseconds since epoch.\n   * field(\"microseconds\").unixMicrosToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMicrosToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_micros_to_timestamp',\n      [this],\n      'unixMicrosToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to microseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMicros();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n   */\n  timestampToUnixMicros(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_micros',\n      [this],\n      'timestampToUnixMicros'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'milliseconds' field as milliseconds since epoch.\n   * field(\"milliseconds\").unixMillisToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixMillisToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_millis_to_timestamp',\n      [this],\n      'unixMillisToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to milliseconds since epoch.\n   * field(\"timestamp\").timestampToUnixMillis();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n   */\n  timestampToUnixMillis(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_millis',\n      [this],\n      'timestampToUnixMillis'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that interprets this expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n   * and returns a timestamp.\n   *\n   * @example\n   * ```typescript\n   * // Interpret the 'seconds' field as seconds since epoch.\n   * field(\"seconds\").unixSecondsToTimestamp();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n   */\n  unixSecondsToTimestamp(): FunctionExpression {\n    return new FunctionExpression(\n      'unix_seconds_to_timestamp',\n      [this],\n      'unixSecondsToTimestamp'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that converts this timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n   *\n   * @example\n   * ```typescript\n   * // Convert the 'timestamp' field to seconds since epoch.\n   * field(\"timestamp\").timestampToUnixSeconds();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n   */\n  timestampToUnixSeconds(): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_to_unix_seconds',\n      [this],\n      'timestampToUnixSeconds'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that adds a specified amount of time to this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Add 1 day to the 'timestamp' field.\n   * field(\"timestamp\").timestampAdd(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to add.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampAdd(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampAdd(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_add',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampAdd'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(field(\"unit\"), field(\"amount\"));\n   * ```\n   *\n   * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n   * @param amount - The expression evaluates to amount of the unit.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(unit: Expression, amount: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that subtracts a specified amount of time from this timestamp expression.\n   *\n   * @example\n   * ```typescript\n   * // Subtract 1 day from the 'timestamp' field.\n   * field(\"timestamp\").timestampSubtract(\"day\", 1);\n   * ```\n   *\n   * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n   * @param amount - The amount of time to subtract.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n   */\n  timestampSubtract(\n    unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n    amount: number\n  ): FunctionExpression;\n  timestampSubtract(\n    unit:\n      | Expression\n      | 'microsecond'\n      | 'millisecond'\n      | 'second'\n      | 'minute'\n      | 'hour'\n      | 'day',\n    amount: Expression | number\n  ): FunctionExpression {\n    return new FunctionExpression(\n      'timestamp_subtract',\n      [this, valueToDefaultExpr(unit), valueToDefaultExpr(amount)],\n      'timestampSubtract'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the document ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the document ID from a path.\n   * field(\"__path__\").documentId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n   */\n  documentId(): FunctionExpression {\n    return new FunctionExpression('document_id', [this], 'documentId');\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - Index of the first character of the substring.\n   * @param length - Length of the substring. If not provided, the substring will\n   * end at the end of the input.\n   */\n  substring(position: number, length?: number): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns a substring of the results of this expression.\n   *\n   * @param position - An expression returning the index of the first character of the substring.\n   * @param length - An expression returning the length of the substring. If not provided the\n   * substring will end at the end of the input.\n   */\n  substring(position: Expression, length?: Expression): FunctionExpression;\n  substring(\n    position: Expression | number,\n    length?: Expression | number\n  ): FunctionExpression {\n    const positionExpr = valueToDefaultExpr(position);\n    if (length === undefined) {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr],\n        'substring'\n      );\n    } else {\n      return new FunctionExpression(\n        'substring',\n        [this, positionExpr, valueToDefaultExpr(length)],\n        'substring'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the 'tags' field array at index `1`.\n   * field('tags').arrayGet(1);\n   * ```\n   *\n   * @param offset - The index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offset: number): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that indexes into an array from the beginning or end\n   * and returns the element. If the offset exceeds the array length, an error is\n   * returned. A negative offset, starts from the end.\n   *\n   * @example\n   * ```typescript\n   * // Return the value in the tags field array at index specified by field\n   * // 'favoriteTag'.\n   * field('tags').arrayGet(field('favoriteTag'));\n   * ```\n   *\n   * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n   * @returns A new `Expression` representing the 'arrayGet' operation.\n   */\n  arrayGet(offsetExpr: Expression): FunctionExpression;\n  arrayGet(offset: Expression | number): FunctionExpression {\n    return new FunctionExpression(\n      'array_get',\n      [this, valueToDefaultExpr(offset)],\n      'arrayGet'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that checks if a given expression produces an error.\n   *\n   * @example\n   * ```typescript\n   * // Check if the result of a calculation is an error\n   * field(\"title\").arrayContains(1).isError();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isError' check.\n   */\n  isError(): BooleanExpression {\n    return new FunctionExpression('is_error', [this], 'isError').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the result of the `catchExpr` argument\n   * if there is an error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // the entire title field if the array is empty or the field is another type.\n   * field(\"title\").arrayGet(0).ifError(field(\"title\"));\n   * ```\n   *\n   * @param catchExpr - The catch expression that will be evaluated and\n   * returned if this expression produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchExpr: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Returns the first item in the title field arrays, or returns\n   * // \"Default Title\"\n   * field(\"title\").arrayGet(0).ifError(\"Default Title\");\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): FunctionExpression | BooleanExpression {\n    const result = new FunctionExpression(\n      'if_error',\n      [this, valueToDefaultExpr(catchValue)],\n      'ifError'\n    );\n\n    return catchValue instanceof BooleanExpression\n      ? result.asBoolean()\n      : result;\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns `true` if the result of this expression\n   * is absent. Otherwise, returns `false` even if the value is `null`.\n   *\n   * @example\n   * ```typescript\n   * // Check if the field `value` is absent.\n   * field(\"value\").isAbsent();\n   * @example\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#BooleanExpression} representing the 'isAbsent' check.\n   */\n  isAbsent(): BooleanExpression {\n    return new FunctionExpression('is_absent', [this], 'isAbsent').asBoolean();\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove('baz');\n   * ```\n   *\n   * @param key - The name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(key: string): FunctionExpression;\n  /**\n   * @beta\n   *\n   * Creates an expression that removes a key from the map produced by evaluating this expression.\n   *\n   * @example\n   * ```\n   * // Removes the key 'baz' from the input map.\n   * map({foo: 'bar', baz: true}).mapRemove(constant('baz'));\n   * @example\n   * ```\n   *\n   * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapRemove' operation.\n   */\n  mapRemove(keyExpr: Expression): FunctionExpression;\n  mapRemove(stringExpr: Expression | string): FunctionExpression {\n    return new FunctionExpression(\n      'map_remove',\n      [this, valueToDefaultExpr(stringExpr)],\n      'mapRemove'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that merges multiple map values.\n   *\n   * @example\n   * ```\n   * // Merges the map in the settings field with, a map literal, and a map in\n   * // that is conditionally returned by another expression\n   * field('settings').mapMerge({ enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n   * ```\n   *\n   * @param secondMap - A required second map to merge. Represented as a literal or\n   * an expression that returns a map.\n   * @param otherMaps - Optional additional maps to merge. Each map is represented\n   * as a literal or an expression that returns a map.\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'mapMerge' operation.\n   */\n  mapMerge(\n    secondMap: Record<string, unknown> | Expression,\n    ...otherMaps: Array<Record<string, unknown> | Expression>\n  ): FunctionExpression {\n    const secondMapExpr = valueToDefaultExpr(secondMap);\n    const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n    return new FunctionExpression(\n      'map_merge',\n      [this, secondMapExpr, ...otherMapExprs],\n      'mapMerge'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of another expression.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of the 'exponent' field.\n   * field(\"base\").pow(field(\"exponent\"));\n   * ```\n   *\n   * @param exponent - The expression to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the value of this expression raised to the power of a constant value.\n   *\n   * @example\n   * ```typescript\n   * // Raise the value of the 'base' field to the power of 2.\n   * field(\"base\").pow(2);\n   * ```\n   *\n   * @param exponent - The constant value to raise this expression to the power of.\n   * @returns A new `Expression` representing the power operation.\n   */\n  pow(exponent: number): FunctionExpression;\n  pow(exponent: number | Expression): FunctionExpression {\n    return new FunctionExpression('pow', [this, valueToDefaultExpr(exponent)]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that truncates the numeric value to an integer.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'rating' field\n   * field(\"rating\").trunc();\n   * ```\n   *\n   * @returns A new `Expression` representing the truncated value.\n   */\n  trunc(): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that truncates a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the value of the 'rating' field to two decimal places.\n   * field(\"rating\").trunc(2);\n   * ```\n   *\n   * @param decimalPlaces - A constant specifying the truncation precision in decimal places.\n   * @returns A new `Expression` representing the truncated value.\n   */\n  trunc(decimalPlaces: number): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that truncates a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the value of the 'rating' field to two decimal places.\n   * field(\"rating\").trunc(constant(2));\n   * ```\n   *\n   * @param decimalPlaces - An expression specifying the truncation precision in decimal places.\n   * @returns A new `Expression` representing the truncated value.\n   */\n  trunc(decimalPlaces: Expression): FunctionExpression;\n  trunc(decimalPlaces?: number | Expression): FunctionExpression {\n    if (decimalPlaces === undefined) {\n      return new FunctionExpression('trunc', [this]);\n    } else {\n      return new FunctionExpression(\n        'trunc',\n        [this, valueToDefaultExpr(decimalPlaces)],\n        'trunc'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the nearest whole number.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field.\n   * field(\"price\").round();\n   * ```\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(2);\n   * ```\n   *\n   * @param decimalPlaces - A constant specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: number): FunctionExpression;\n  /**\n   * @beta\n   * Creates an expression that rounds a numeric value to the specified number of decimal places.\n   *\n   * @example\n   * ```typescript\n   * // Round the value of the 'price' field to two decimal places.\n   * field(\"price\").round(constant(2));\n   * ```\n   *\n   * @param decimalPlaces - An expression specifying the rounding precision in decimal places.\n   *\n   * @returns A new `Expression` representing the rounded value.\n   */\n  round(decimalPlaces: Expression): FunctionExpression;\n  round(decimalPlaces?: number | Expression): FunctionExpression {\n    if (decimalPlaces === undefined) {\n      return new FunctionExpression('round', [this]);\n    } else {\n      return new FunctionExpression(\n        'round',\n        [this, valueToDefaultExpr(decimalPlaces)],\n        'round'\n      );\n    }\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the collection ID from a path.\n   *\n   * @example\n   * ```typescript\n   * // Get the collection ID from a path.\n   * field(\"__path__\").collectionId();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n   */\n  collectionId(): FunctionExpression {\n    return new FunctionExpression('collection_id', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n   *\n   * @example\n   * ```typescript\n   * // Get the length of the 'name' field.\n   * field(\"name\").length();\n   *\n   * // Get the number of items in the 'cart' array.\n   * field(\"cart\").length();\n   * ```\n   *\n   * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n   */\n  length(): FunctionExpression {\n    return new FunctionExpression('length', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the natural logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the natural logarithm of the 'value' field.\n   * field(\"value\").ln();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the natural logarithm of the numeric value.\n   */\n  ln(): FunctionExpression {\n    return new FunctionExpression('ln', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the square root of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the square root of the 'value' field.\n   * field(\"value\").sqrt();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n   */\n  sqrt(): FunctionExpression {\n    return new FunctionExpression('sqrt', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that reverses a string.\n   *\n   * @example\n   * ```typescript\n   * // Reverse the value of the 'myString' field.\n   * field(\"myString\").stringReverse();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n   */\n  stringReverse(): FunctionExpression {\n    return new FunctionExpression('string_reverse', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of the this expression evaluation.\n   *\n   * @example\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n   * // if the field is absent.\n   * field(\"optional_field\").ifAbsent(\"default_value\")\n   * ```\n   *\n   * @param elseValue - The value that will be returned if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseValue: unknown): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that returns the `elseValue` argument if this expression results in an absent value, else\n   * return the result of this expression evaluation.\n   *\n   * ```typescript\n   * // Returns the value of the optional field 'optional_field', or if that is\n   * // absent, then returns the value of the field `\n   * field(\"optional_field\").ifAbsent(field('default_field'))\n   * ```\n   *\n   * @param elseExpression - The Expression that will be evaluated if this Expression evaluates to an absent value.\n   * @returns A new [Expression] representing the ifAbsent operation.\n   */\n  ifAbsent(elseExpression: unknown): Expression;\n\n  ifAbsent(elseValueOrExpression: Expression | unknown): Expression {\n    return new FunctionExpression(\n      'if_absent',\n      [this, valueToDefaultExpr(elseValueOrExpression)],\n      'ifAbsent'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n   * field(\"tags\").join(field(\"separator\"))\n   * ```\n   *\n   * @param delimiterExpression - The expression that evaluates to the delimiter string.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiterExpression: Expression): Expression;\n\n  /**\n   * @beta\n   * Creates an expression that joins the elements of an array field into a string.\n   *\n   * @example\n   * ```typescript\n   * // Join the elements of the 'tags' field with a comma and space.\n   * field(\"tags\").join(\", \")\n   * ```\n   *\n   * @param delimiter - The string to use as a delimiter.\n   * @returns A new Expression representing the join operation.\n   */\n  join(delimiter: string): Expression;\n\n  join(delimeterValueOrExpression: string | Expression): Expression {\n    return new FunctionExpression(\n      'join',\n      [this, valueToDefaultExpr(delimeterValueOrExpression)],\n      'join'\n    );\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the base-10 logarithm of a numeric value.\n   *\n   * @example\n   * ```typescript\n   * // Compute the base-10 logarithm of the 'value' field.\n   * field(\"value\").log10();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the base-10 logarithm of the numeric value.\n   */\n  log10(): FunctionExpression {\n    return new FunctionExpression('log10', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that computes the sum of the elements in an array.\n   *\n   * @example\n   * ```typescript\n   * // Compute the sum of the elements in the 'scores' field.\n   * field(\"scores\").arraySum();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the sum of the elements in the array.\n   */\n  arraySum(): FunctionExpression {\n    return new FunctionExpression('sum', [this]);\n  }\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scoresCsv' field on delimiter ','\n   * field('scoresCsv').split(',')\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: string): FunctionExpression;\n\n  /**\n   * @beta\n   * Creates an expression that splits the result of this expression into an\n   * array of substrings based on the provided delimiter.\n   *\n   * @example\n   * ```typescript\n   * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n   * field('scores').split(conditional(field('format').equal('csv'), constant(','), constant(':'))\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n   */\n  split(delimiter: Expression): FunctionExpression;\n  split(delimiter: string | Expression): FunctionExpression {\n    return new FunctionExpression('split', [\n      this,\n      valueToDefaultExpr(delimiter)\n    ]);\n  }\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the beginning of the day.\n   * field('createdAt').timestampTruncate('day')\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: TimeGranularity,\n    timezone?: string | Expression\n  ): FunctionExpression;\n\n  /**\n   * Creates an expression that truncates a timestamp to a specified granularity.\n   *\n   * @example\n   * ```typescript\n   * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n   * field('createdAt').timestampTruncate(field('granularity'))\n   * ```\n   *\n   * @param granularity - The granularity to truncate to.\n   * @param timezone - The timezone to use for truncation. Valid values are from\n   * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n   * @returns A new `Expression` representing the truncated timestamp.\n   */\n  timestampTruncate(\n    granularity: Expression,\n    timezone?: string | Expression\n  ): FunctionExpression;\n  timestampTruncate(\n    granularity: TimeGranularity | Expression,\n    timezone?: string | Expression\n  ): FunctionExpression {\n    const internalGranularity = isString(granularity)\n      ? granularity.toLowerCase()\n      : granularity;\n\n    const args = [this, valueToDefaultExpr(internalGranularity)];\n    if (timezone) {\n      args.push(valueToDefaultExpr(timezone));\n    }\n    return new FunctionExpression('timestamp_trunc', args);\n  }\n\n  // TODO(new-expression): Add new expression method definitions above this line\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'name' field in ascending order\n   * pipeline().collection(\"users\")\n   *   .sort(field(\"name\").ascending());\n   * ```\n   *\n   * @returns A new `Ordering` for ascending sorting.\n   */\n  ascending(): Ordering {\n    return ascending(this);\n  }\n\n  /**\n   * @beta\n   * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on this expression.\n   *\n   * @example\n   * ```typescript\n   * // Sort documents by the 'createdAt' field in descending order\n   * firestore.pipeline().collection(\"users\")\n   *   .sort(field(\"createdAt\").descending());\n   * ```\n   *\n   * @returns A new `Ordering` for descending sorting.\n   */\n  descending(): Ordering {\n    return descending(this);\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this expression.\n   *\n   * Aliases are useful for renaming fields in the output of a stage or for giving meaningful\n   * names to calculated values.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the total price and assign it the alias \"totalPrice\" and add it to the output.\n   * firestore.pipeline().collection(\"items\")\n   *   .addFields(field(\"price\").multiply(field(\"quantity\")).as(\"totalPrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this expression.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedExpression} that wraps this\n   *     expression and associates it with the provided alias.\n   */\n  as(name: string): AliasedExpression {\n    return new AliasedExpression(this, name, 'as');\n  }\n}\n\n/**\n * @beta\n * Specify time granularity for expressions.\n */\nexport type TimeGranularity =\n  | 'microsecond'\n  | 'millisecond'\n  | 'second'\n  | 'minute'\n  | 'hour'\n  | 'day'\n  | 'week'\n  | 'week(monday)'\n  | 'week(tuesday)'\n  | 'week(wednesday)'\n  | 'week(thursday)'\n  | 'week(friday)'\n  | 'week(saturday)'\n  | 'week(sunday)'\n  | 'isoWeek'\n  | 'month'\n  | 'quarter'\n  | 'year'\n  | 'isoYear';\n\n/**\n * @beta\n *\n * An interface that represents a selectable expression.\n */\nexport interface Selectable {\n  selectable: true;\n  /**\n   * @private\n   * @internal\n   */\n  readonly alias: string;\n  /**\n   * @private\n   * @internal\n   */\n  readonly expr: Expression;\n}\n\n/**\n * @beta\n *\n * A class that represents an aggregate function.\n */\nexport class AggregateFunction implements ProtoValueSerializable, UserData {\n  exprType: ExpressionType = 'AggregateFunction';\n\n  /**\n   * @internal\n   */\n  _methodName?: string;\n\n  constructor(private name: string, private params: Expression[]) {}\n\n  /**\n   * @internal\n   * @private\n   */\n  static _create(\n    name: string,\n    params: Expression[],\n    methodName: string\n  ): AggregateFunction {\n    const af = new AggregateFunction(name, params);\n    af._methodName = methodName;\n\n    return af;\n  }\n\n  /**\n   * @beta\n   * Assigns an alias to this AggregateFunction. The alias specifies the name that\n   * the aggregated value will have in the output document.\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average price of all items and assign it the alias \"averagePrice\".\n   * firestore.pipeline().collection(\"items\")\n   *   .aggregate(field(\"price\").average().as(\"averagePrice\"));\n   * ```\n   *\n   * @param name - The alias to assign to this AggregateFunction.\n   * @returns A new {@link @firebase/firestore/pipelines#AliasedAggregate} that wraps this\n   *     AggregateFunction and associates it with the provided alias.\n   */\n  as(name: string): AliasedAggregate {\n    return new AliasedAggregate(this, name, 'as');\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  _protoValueType = 'ProtoValue' as const;\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An AggregateFunction with alias.\n */\nexport class AliasedAggregate implements UserData {\n  constructor(\n    readonly aggregate: AggregateFunction,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.aggregate._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class AliasedExpression implements Selectable, UserData {\n  exprType: ExpressionType = 'AliasedExpression';\n  selectable = true as const;\n\n  constructor(\n    readonly expr: Expression,\n    readonly alias: string,\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n}\n\n/**\n * @internal\n */\nclass ListOfExprs extends Expression implements UserData {\n  expressionType: ExpressionType = 'ListOfExpressions';\n\n  constructor(\n    private exprs: Expression[],\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      arrayValue: {\n        values: this.exprs.map(p => p._toProto(serializer)!)\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.exprs.forEach((expr: Expression) => expr._readUserData(context));\n  }\n}\n\n/**\n * @beta\n *\n * Represents a reference to a field in a Firestore document, or outputs of a {@link @firebase/firestore/pipelines#Pipeline} stage.\n *\n * <p>Field references are used to access document field values in expressions and to specify fields\n * for sorting, filtering, and projecting data in Firestore pipelines.\n *\n * <p>You can create a `Field` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'name' field\n * const nameField = field(\"name\");\n *\n * // Create a Field instance for a nested field 'address.city'\n * const cityField = field(\"address.city\");\n * ```\n */\nexport class Field extends Expression implements Selectable {\n  readonly expressionType: ExpressionType = 'Field';\n  selectable = true as const;\n\n  /**\n   * @internal\n   * @private\n   * @hideconstructor\n   * @param fieldPath\n   */\n  constructor(\n    private fieldPath: InternalFieldPath,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  get fieldName(): string {\n    return this.fieldPath.canonicalString();\n  }\n\n  get alias(): string {\n    return this.fieldName;\n  }\n\n  get expr(): Expression {\n    return this;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      fieldReferenceValue: this.fieldPath.canonicalString()\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {}\n}\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * The path can be a simple field name (e.g., \"name\") or a dot-separated path to a nested field\n * (e.g., \"address.city\").\n *\n * @example\n * ```typescript\n * // Create a Field instance for the 'title' field\n * const titleField = field(\"title\");\n *\n * // Create a Field instance for a nested field 'author.firstName'\n * const authorFirstNameField = field(\"author.firstName\");\n * ```\n *\n * @param name - The path to the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(name: string): Field;\n\n/**\n * @beta\n * Creates a {@link @firebase/firestore/pipelines#Field} instance representing the field at the given path.\n *\n * @param path - A FieldPath specifying the field.\n * @returns A new {@link @firebase/firestore/pipelines#Field} instance representing the specified field.\n */\nexport function field(path: FieldPath): Field;\nexport function field(nameOrPath: string | FieldPath): Field {\n  return _field(nameOrPath, 'field');\n}\n\nexport function _field(\n  nameOrPath: string | FieldPath,\n  methodName: string | undefined\n): Field {\n  if (typeof nameOrPath === 'string') {\n    if (DOCUMENT_KEY_NAME === nameOrPath) {\n      return new Field(documentIdFieldPath()._internalPath, methodName);\n    }\n    return new Field(fieldPathFromArgument('field', nameOrPath), methodName);\n  } else {\n    return new Field(nameOrPath._internalPath, methodName);\n  }\n}\n\n/**\n * @internal\n *\n * Represents a constant value that can be used in a Firestore pipeline expression.\n *\n * You can create a `Constant` instance using the static {@link @firebase/firestore/pipelines#field} method:\n *\n * @example\n * ```typescript\n * // Create a Constant instance for the number 10\n * const ten = constant(10);\n *\n * // Create a Constant instance for the string \"hello\"\n * const hello = constant(\"hello\");\n * ```\n */\nexport class Constant extends Expression {\n  readonly expressionType: ExpressionType = 'Constant';\n\n  private _protoValue?: ProtoValue;\n\n  /**\n   * @private\n   * @internal\n   * @hideconstructor\n   * @param value - The value of the constant.\n   */\n  constructor(\n    private value: unknown,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  static _fromProto(value: ProtoValue): Constant {\n    const result = new Constant(value, undefined);\n    result._protoValue = value;\n    return result;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(_: JsonProtoSerializer): ProtoValue {\n    hardAssert(\n      this._protoValue !== undefined,\n      0x00ed,\n      'Value of this constant has not been serialized to proto value'\n    );\n    return this._protoValue;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    if (isFirestoreValue(this._protoValue)) {\n      return;\n    } else {\n      this._protoValue = parseData(this.value, context)!;\n    }\n  }\n}\n\n/**\n * @beta\n * Creates a `Constant` instance for a number value.\n *\n * @param value - The number value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: number): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a string value.\n *\n * @param value - The string value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: string): Expression;\n\n/**\n * @beta\n * Creates a `BooleanExpression` instance for a boolean value.\n *\n * @param value - The boolean value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: boolean): BooleanExpression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a null value.\n *\n * @param value - The null value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: null): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a GeoPoint value.\n *\n * @param value - The GeoPoint value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: GeoPoint): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Timestamp value.\n *\n * @param value - The Timestamp value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Timestamp): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Date value.\n *\n * @param value - The Date value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Date): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a Bytes value.\n *\n * @param value - The Bytes value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: Bytes): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a DocumentReference value.\n *\n * @param value - The DocumentReference value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: DocumentReference): Expression;\n\n/**\n * Creates a `Constant` instance for a Firestore proto value.\n * For internal use only.\n * @private\n * @internal\n * @param value - The Firestore proto value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: ProtoValue): Expression;\n\n/**\n * @beta\n * Creates a `Constant` instance for a VectorValue value.\n *\n * @param value - The VectorValue value.\n * @returns A new `Constant` instance.\n */\nexport function constant(value: VectorValue): Expression;\n\nexport function constant(value: unknown): Expression | BooleanExpression {\n  return _constant(value, 'constant');\n}\n\n/**\n * @internal\n * @private\n * @param value\n * @param methodName\n */\nexport function _constant(\n  value: unknown,\n  methodName: string | undefined\n): Constant | BooleanExpression {\n  const c = new Constant(value, methodName);\n  if (typeof value === 'boolean') {\n    return new BooleanConstant(c);\n  } else {\n    return c;\n  }\n}\n\n/**\n * Internal only\n * @internal\n * @private\n */\nexport class MapValue extends Expression {\n  constructor(\n    private plainObject: Map<string, Expression>,\n    readonly _methodName: string | undefined\n  ) {\n    super();\n  }\n\n  expressionType: ExpressionType = 'Constant';\n\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.plainObject.forEach(expr => {\n      expr._readUserData(context);\n    });\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return toMapValue(serializer, this.plainObject);\n  }\n}\n\n/**\n * @beta\n *\n * This class defines the base class for Firestore {@link @firebase/firestore/pipelines#Pipeline} functions, which can be evaluated within pipeline\n * execution.\n *\n * Typically, you would not use this class or its children directly. Use either the functions like {@link @firebase/firestore/pipelines#and}, {@link @firebase/firestore/pipelines#(equal:1)},\n * or the methods on {@link @firebase/firestore/pipelines#Expression} ({@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, etc.) to construct new Function instances.\n */\nexport class FunctionExpression extends Expression {\n  readonly expressionType: ExpressionType = 'Function';\n\n  constructor(name: string, params: Expression[]);\n  constructor(\n    name: string,\n    params: Expression[],\n    _methodName: string | undefined\n  );\n  constructor(\n    private name: string,\n    private params: Expression[],\n    readonly _methodName?: string\n  ) {\n    super();\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      functionValue: {\n        name: this.name,\n        args: this.params.map(p => p._toProto(serializer))\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    context = this._methodName\n      ? context.contextWith({ methodName: this._methodName })\n      : context;\n    this.params.forEach(expr => {\n      return expr._readUserData(context);\n    });\n  }\n}\n\n/**\n * @beta\n *\n * An interface that represents a filter condition.\n */\nexport abstract class BooleanExpression extends Expression {\n  abstract get _expr(): Expression;\n\n  get _methodName(): string | undefined {\n    return this._expr._methodName;\n  }\n\n  /**\n   * @beta\n   * Creates an aggregation that finds the count of input documents satisfying\n   * this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find the count of documents with a score greater than 90\n   * field(\"score\").greaterThan(90).countIf().as(\"highestScore\");\n   * ```\n   *\n   * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n   */\n  countIf(): AggregateFunction {\n    return AggregateFunction._create('count_if', [this], 'countIf');\n  }\n\n  /**\n   * @beta\n   * Creates an expression that negates this boolean expression.\n   *\n   * @example\n   * ```typescript\n   * // Find documents where the 'tags' field does not contain 'completed'\n   * field(\"tags\").arrayContains(\"completed\").not();\n   * ```\n   *\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n   */\n  not(): BooleanExpression {\n    return new FunctionExpression('not', [this], 'not').asBoolean();\n  }\n\n  /**\n   * @beta\n   * Creates a conditional expression that evaluates to the 'then' expression\n   * if `this` expression evaluates to `true`,\n   * or evaluates to the 'else' expression if `this` expressions evaluates `false`.\n   *\n   * @example\n   * ```typescript\n   * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n   * field(\"age\").greaterThanOrEqual(18).conditional(constant(\"Adult\"), constant(\"Minor\"));\n   * ```\n   *\n   * @param thenExpr - The expression to evaluate if the condition is true.\n   * @param elseExpr - The expression to evaluate if the condition is false.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n   */\n  conditional(thenExpr: Expression, elseExpr: Expression): FunctionExpression {\n    return new FunctionExpression(\n      'conditional',\n      [this, thenExpr, elseExpr],\n      'conditional'\n    );\n  }\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(constant(false));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: BooleanExpression): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error\n   * // but always returns a boolean expression.\n   * constant(50).divide('length').gt(1).ifError(false);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: boolean): BooleanExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(constant(0));\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: Expression): FunctionExpression;\n\n  /**\n   * @beta\n   *\n   * Creates an expression that returns the `catch` argument if there is an\n   * error, else return the result of this expression.\n   *\n   * @example\n   * ```typescript\n   * // Create an expression that protects against a divide by zero error.\n   * constant(50).divide('length').gt(1).ifError(0);\n   * ```\n   *\n   * @param catchValue - The value that will be returned if this expression\n   * produces an error.\n   * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n   */\n  ifError(catchValue: unknown): FunctionExpression;\n  ifError(catchValue: unknown): unknown {\n    const normalizedCatchValue = valueToDefaultExpr(catchValue);\n    const expr = new FunctionExpression(\n      'if_error',\n      [this, normalizedCatchValue],\n      'ifError'\n    );\n\n    return normalizedCatchValue instanceof BooleanExpression\n      ? expr.asBoolean()\n      : expr;\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return this._expr._toProto(serializer);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this._expr._readUserData(context);\n  }\n}\n\nexport class BooleanFunctionExpression extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Function';\n  constructor(readonly _expr: FunctionExpression) {\n    super();\n  }\n}\n\nexport class BooleanConstant extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Constant';\n  constructor(readonly _expr: Constant) {\n    super();\n  }\n}\n\nexport class BooleanField extends BooleanExpression {\n  readonly expressionType: ExpressionType = 'Field';\n  constructor(readonly _expr: Field) {\n    super();\n  }\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the provided\n * boolean expression evaluates to true.\n *\n * @example\n * ```typescript\n * // Count the number of documents where 'is_active' field equals true\n * countIf(field(\"is_active\").equal(true)).as(\"numActiveDocuments\");\n * ```\n *\n * @param booleanExpr - The boolean expression to evaluate on each input.\n * @returns A new `AggregateFunction` representing the 'countIf' aggregation.\n */\nexport function countIf(booleanExpr: BooleanExpression): AggregateFunction {\n  return booleanExpr.countIf();\n}\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet('tags', 1);\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet('tags', field('favoriteTag'));\n * ```\n *\n * @param arrayField - The name of the array field.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayField: string,\n  offsetExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index 1.\n * arrayGet(field('tags'), 1);\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offset - The index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offset: number\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that indexes into an array from the beginning or end\n * and return the element. If the offset exceeds the array length, an error is\n * returned. A negative offset, starts from the end.\n *\n * @example\n * ```typescript\n * // Return the value in the tags field array at index specified by field\n * // 'favoriteTag'.\n * arrayGet(field('tags'), field('favoriteTag'));\n * ```\n *\n * @param arrayExpression - An `Expression` evaluating to an array.\n * @param offsetExpr - An `Expression` evaluating to the index of the element to return.\n * @returns A new `Expression` representing the 'arrayGet' operation.\n */\nexport function arrayGet(\n  arrayExpression: Expression,\n  offsetExpr: Expression\n): FunctionExpression;\nexport function arrayGet(\n  array: Expression | string,\n  offset: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(array).arrayGet(valueToDefaultExpr(offset));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a given expression produces an error.\n *\n * @example\n * ```typescript\n * // Check if the result of a calculation is an error\n * isError(field(\"title\").arrayContains(1));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isError' check.\n */\nexport function isError(value: Expression): BooleanExpression {\n  return value.isError().asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * This overload is useful when a BooleanExpression is required.\n *\n * @example\n * ```typescript\n * // Create an expression that protects against a divide by zero error\n * // but always returns a boolean expression.\n * ifError(constant(50).divide('length').gt(1), constant(false));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: BooleanExpression,\n  catchExpr: BooleanExpression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // the entire title field if the array is empty or the field is another type.\n * ifError(field(\"title\").arrayGet(0), field(\"title\"));\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchExpr - The catch expression that will be evaluated and\n * returned if the tryExpr produces an error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchExpr: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the `catch` argument if there is an\n * error, else return the result of the `try` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the first item in the title field arrays, or returns\n * // \"Default Title\"\n * ifError(field(\"title\").arrayGet(0), \"Default Title\");\n * ```\n *\n * @param tryExpr - The try expression.\n * @param catchValue - The value that will be returned if the tryExpr produces an\n * error.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ifError' operation.\n */\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression;\n\nexport function ifError(\n  tryExpr: Expression,\n  catchValue: unknown\n): FunctionExpression | BooleanExpression {\n  if (\n    tryExpr instanceof BooleanExpression &&\n    catchValue instanceof BooleanExpression\n  ) {\n    return tryExpr.ifError(catchValue).asBoolean();\n  } else {\n    return tryExpr.ifError(valueToDefaultExpr(catchValue));\n  }\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a value is absent. Otherwise,\n * returns `false` even if the value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(field(\"value\"));\n * ```\n *\n * @param value - The expression to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns `true` if a field is absent. Otherwise,\n * returns `false` even if the field value is `null`.\n *\n * @example\n * ```typescript\n * // Check if the field `value` is absent.\n * isAbsent(\"value\");\n * ```\n *\n * @param field - The field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'isAbsent' check.\n */\nexport function isAbsent(field: string): BooleanExpression;\nexport function isAbsent(value: Expression | string): BooleanExpression {\n  return fieldOrExpression(value).isAbsent();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', 'city');\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapField: string, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), 'baz');\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param key - The name of the key to remove from the input map.\n */\nexport function mapRemove(mapExpr: Expression, key: string): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map at the specified field name.\n *\n * @example\n * ```\n * // Removes the key 'city' field from the map in the address field of the input document.\n * mapRemove('address', constant('city'));\n * ```\n *\n * @param mapField - The name of a field containing a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapField: string,\n  keyExpr: Expression\n): FunctionExpression;\n/**\n * @beta\n *\n * Creates an expression that removes a key from the map produced by evaluating an expression.\n *\n * @example\n * ```\n * // Removes the key 'baz' from the input map.\n * mapRemove(map({foo: 'bar', baz: true}), constant('baz'));\n * @example\n * ```\n *\n * @param mapExpr - An expression return a map value.\n * @param keyExpr - An expression that produces the name of the key to remove from the input map.\n */\nexport function mapRemove(\n  mapExpr: Expression,\n  keyExpr: Expression\n): FunctionExpression;\n\nexport function mapRemove(\n  mapExpr: Expression | string,\n  stringExpr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(mapExpr).mapRemove(valueToDefaultExpr(stringExpr));\n}\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge('settings', { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param mapField - Name of a field containing a map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  mapField: string,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that merges multiple map values.\n *\n * @example\n * ```\n * // Merges the map in the settings field with, a map literal, and a map in\n * // that is conditionally returned by another expression\n * mapMerge(field('settings'), { enabled: true }, conditional(field('isAdmin'), { admin: true}, {})\n * ```\n *\n * @param firstMap - An expression or literal map value that will be merged.\n * @param secondMap - A required second map to merge. Represented as a literal or\n * an expression that returns a map.\n * @param otherMaps - Optional additional maps to merge. Each map is represented\n * as a literal or an expression that returns a map.\n */\nexport function mapMerge(\n  firstMap: Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression;\n\nexport function mapMerge(\n  firstMap: string | Record<string, unknown> | Expression,\n  secondMap: Record<string, unknown> | Expression,\n  ...otherMaps: Array<Record<string, unknown> | Expression>\n): FunctionExpression {\n  const secondMapExpr = valueToDefaultExpr(secondMap);\n  const otherMapExprs = otherMaps.map(valueToDefaultExpr);\n  return fieldOrExpression(firstMap).mapMerge(secondMapExpr, ...otherMapExprs);\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(myDocumentReference);\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(\n  documentPath: string | DocumentReference\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the document ID from a path.\n *\n * @example\n * ```typescript\n * // Get the document ID from a path.\n * documentId(field(\"__path__\"));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the documentId operation.\n */\nexport function documentId(documentPathExpr: Expression): FunctionExpression;\n\nexport function documentId(\n  documentPath: Expression | string | DocumentReference\n): FunctionExpression {\n  // @ts-ignore\n  const documentPathExpr = valueToDefaultExpr(documentPath);\n  return documentPathExpr.documentId();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  field: string,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - Index of the first character of the substring.\n * @param length - Length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: number,\n  length?: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param field - The name of a field containing a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  field: string,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns a substring of a string or byte array.\n *\n * @param input - An expression returning a string or byte array to compute the substring from.\n * @param position - An expression that returns the index of the first character of the substring.\n * @param length - An expression that returns the length of the substring.\n */\nexport function substring(\n  input: Expression,\n  position: Expression,\n  length?: Expression\n): FunctionExpression;\n\nexport function substring(\n  field: Expression | string,\n  position: Expression | number,\n  length?: Expression | number\n): FunctionExpression {\n  const fieldExpr = fieldOrExpression(field);\n  const positionExpr = valueToDefaultExpr(position);\n  const lengthExpr =\n    length === undefined ? undefined : valueToDefaultExpr(length);\n  return fieldExpr.substring(positionExpr, lengthExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds two expressions together.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(field(\"quantity\"), field(\"reserve\"));\n * ```\n *\n * @param first - The first expression to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a field's value to an expression.\n *\n * @example\n * ```typescript\n * // Add the value of the 'quantity' field and the 'reserve' field.\n * add(\"quantity\", field(\"reserve\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the addition operation.\n */\nexport function add(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function add(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).add(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts two expressions.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(field(\"price\"), field(\"discount\"));\n * ```\n *\n * @param left - The expression to subtract from.\n * @param right - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  left: Expression,\n  right: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from an expression.\n *\n * @example\n * ```typescript\n * // Subtract the constant value 2 from the 'value' field\n * subtract(field(\"value\"), 2);\n * ```\n *\n * @param expression - The expression to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts an expression from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract the 'discount' field from the 'price' field\n * subtract(\"price\", field(\"discount\"));\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param expression - The expression to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a constant value from a field's value.\n *\n * @example\n * ```typescript\n * // Subtract 20 from the value of the 'total' field\n * subtract(\"total\", 20);\n * ```\n *\n * @param fieldName - The field name to subtract from.\n * @param value - The constant value to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the subtraction operation.\n */\nexport function subtract(fieldName: string, value: unknown): FunctionExpression;\nexport function subtract(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.subtract(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that multiplies two expressions together.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(field(\"quantity\"), field(\"price\"));\n * ```\n *\n * @param first - The first expression to multiply.\n * @param second - The second expression or literal to multiply.\n * @param others - Optional additional expressions or literals to multiply.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  first: Expression,\n  second: Expression | unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that multiplies a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Multiply the 'quantity' field by the 'price' field\n * multiply(\"quantity\", field(\"price\"));\n * ```\n *\n * @param fieldName - The name of the field containing the value to add.\n * @param second - The second expression or literal to add.\n * @param others - Optional other expressions or literals to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the multiplication operation.\n */\nexport function multiply(\n  fieldName: string,\n  second: Expression | unknown\n): FunctionExpression;\n\nexport function multiply(\n  first: Expression | string,\n  second: Expression | unknown\n): FunctionExpression {\n  return fieldOrExpression(first).multiply(valueToDefaultExpr(second));\n}\n\n/**\n * @beta\n *\n * Creates an expression that divides two expressions.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(field(\"total\"), field(\"count\"));\n * ```\n *\n * @param left - The expression to be divided.\n * @param right - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides an expression by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(field(\"value\"), 10);\n * ```\n *\n * @param expression - The expression to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  expression: Expression,\n  value: unknown\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Divide the 'total' field by the 'count' field\n * divide(\"total\", field(\"count\"));\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param expressions - The expression to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(\n  fieldName: string,\n  expressions: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that divides a field's value by a constant value.\n *\n * @example\n * ```typescript\n * // Divide the 'value' field by 10\n * divide(\"value\", 10);\n * ```\n *\n * @param fieldName - The field name to be divided.\n * @param value - The constant value to divide by.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the division operation.\n */\nexport function divide(fieldName: string, value: unknown): FunctionExpression;\nexport function divide(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.divide(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing two expressions.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(field(\"field1\"), field(\"field2\"));\n * ```\n *\n * @param left - The dividend expression.\n * @param right - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(left: Expression, right: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing an expression by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(field(\"field1\"), 5);\n * ```\n *\n * @param expression - The dividend expression.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(expression: Expression, value: unknown): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by an expression.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 'field2'.\n * mod(\"field1\", field(\"field2\"));\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param expression - The divisor expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(\n  fieldName: string,\n  expression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the modulo (remainder) of dividing a field's value by a constant.\n *\n * @example\n * ```typescript\n * // Calculate the remainder of dividing 'field1' by 5.\n * mod(\"field1\", 5);\n * ```\n *\n * @param fieldName - The dividend field name.\n * @param value - The divisor constant.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the modulo operation.\n */\nexport function mod(fieldName: string, value: unknown): FunctionExpression;\nexport function mod(\n  left: Expression | string,\n  right: Expression | unknown\n): FunctionExpression {\n  const normalizedLeft = typeof left === 'string' ? field(left) : left;\n  const normalizedRight = valueToDefaultExpr(right);\n  return normalizedLeft.mod(normalizedRight);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore map value from an input object.\n *\n * @example\n * ```typescript\n * // Create a map from the input object and reference the 'baz' field value from the input document.\n * map({foo: 'bar', baz: Field.of('baz')}).as('data');\n * ```\n *\n * @param elements - The input map to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the map function.\n */\nexport function map(elements: Record<string, unknown>): FunctionExpression {\n  return _map(elements, 'map');\n}\nexport function _map(\n  elements: Record<string, unknown>,\n  methodName: string | undefined\n): FunctionExpression {\n  const result: Expression[] = [];\n  for (const key in elements) {\n    if (Object.prototype.hasOwnProperty.call(elements, key)) {\n      const value = elements[key];\n      result.push(constant(key));\n      result.push(valueToDefaultExpr(value));\n    }\n  }\n  return new FunctionExpression('map', result, 'map');\n}\n\n/**\n * Internal use only\n * Converts a plainObject to a mapValue in the proto representation,\n * rather than a functionValue+map that is the result of the map(...) function.\n * This behaves different from constant(plainObject) because it\n * traverses the input object, converts values in the object to expressions,\n * and calls _readUserData on each of these expressions.\n * @private\n * @internal\n * @param plainObject\n */\nexport function _mapValue(plainObject: Record<string, unknown>): MapValue {\n  const result: Map<string, Expression> = new Map<string, Expression>();\n  for (const key in plainObject) {\n    if (Object.prototype.hasOwnProperty.call(plainObject, key)) {\n      const value = plainObject[key];\n      result.set(key, valueToDefaultExpr(value));\n    }\n  }\n  return new MapValue(result, undefined);\n}\n\n/**\n * @beta\n *\n * Creates an expression that creates a Firestore array value from an input array.\n *\n * @example\n * ```typescript\n * // Create an array value from the input array and reference the 'baz' field value from the input document.\n * array(['bar', Field.of('baz')]).as('foo');\n * ```\n *\n * @param elements - The input array to evaluate in the expression.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the array function.\n */\nexport function array(elements: unknown[]): FunctionExpression {\n  return _array(elements, 'array');\n}\nexport function _array(\n  elements: unknown[],\n  methodName: string | undefined\n): FunctionExpression {\n  return new FunctionExpression(\n    'array',\n    elements.map(element => valueToDefaultExpr(element)),\n    methodName\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are equal.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to an expression\n * equal(field(\"age\"), field(\"minAge\").add(10));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(left: Expression, right: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to 21\n * equal(field(\"age\"), 21);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is equal to the 'limit' field\n * equal(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'city' field is equal to string constant \"London\"\n * equal(\"city\", \"London\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the equality comparison.\n */\nexport function equal(fieldName: string, value: unknown): BooleanExpression;\nexport function equal(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.equal(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if two expressions are not equal.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to field 'finalState'\n * notEqual(field(\"status\"), field(\"finalState\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to \"completed\"\n * notEqual(field(\"status\"), \"completed\");\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to the value of 'expectedStatus'\n * notEqual(\"status\", field(\"expectedStatus\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'country' field is not equal to \"USA\"\n * notEqual(\"country\", \"USA\");\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the inequality comparison.\n */\nexport function notEqual(fieldName: string, value: unknown): BooleanExpression;\nexport function notEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.notEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than the second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than 30\n * lessThan(field(\"age\"), 30);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is less than the 'limit' field\n * lessThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is less than 50\n * lessThan(\"price\", 50);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than comparison.\n */\nexport function lessThan(fieldName: string, value: unknown): BooleanExpression;\nexport function lessThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is less than or equal to the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), field(\"limit\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to 20\n * lessThan(field(\"quantity\"), 20);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n * Creates an expression that checks if a field's value is less than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is less than or equal to the 'limit' field\n * lessThan(\"quantity\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is less than or equal to a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is less than or equal to 70\n * lessThan(\"score\", 70);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the less than or equal to comparison.\n */\nexport function lessThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function lessThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.lessThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than the second\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), Constant(9).add(9));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18\n * greaterThan(field(\"age\"), 18);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than the value of field 'limit'\n * greaterThan(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param expression - The expression to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  expression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than a constant value.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is greater than 100\n * greaterThan(\"price\", 100);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than comparison.\n */\nexport function greaterThan(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThan(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThan(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if the first expression is greater than or equal to the\n * second expression.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to the field \"threshold\"\n * greaterThanOrEqual(field(\"quantity\"), field(\"threshold\"));\n * ```\n *\n * @param left - The first expression to compare.\n * @param right - The second expression to compare.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  left: Expression,\n  right: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'quantity' field is greater than or equal to 10\n * greaterThanOrEqual(field(\"quantity\"), 10);\n * ```\n *\n * @param expression - The expression to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  expression: Expression,\n  value: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to an expression.\n *\n * @example\n * ```typescript\n * // Check if the value of field 'age' is greater than or equal to the value of field 'limit'\n * greaterThanOrEqual(\"age\", field(\"limit\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The expression to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is greater than or equal to a constant\n * value.\n *\n * @example\n * ```typescript\n * // Check if the 'score' field is greater than or equal to 80\n * greaterThanOrEqual(\"score\", 80);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param value - The constant value to compare to.\n * @returns A new `Expression` representing the greater than or equal to comparison.\n */\nexport function greaterThanOrEqual(\n  fieldName: string,\n  value: unknown\n): BooleanExpression;\nexport function greaterThanOrEqual(\n  left: Expression | string,\n  right: unknown\n): BooleanExpression {\n  const leftExpr = left instanceof Expression ? left : field(left);\n  const rightExpr = valueToDefaultExpr(right);\n  return leftExpr.greaterThanOrEqual(rightExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates an array expression with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(field(\"items\"), [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArray - The first array expression to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArray: Expression,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that concatenates a field's array value with other arrays.\n *\n * @example\n * ```typescript\n * // Combine the 'items' array with two new item arrays\n * arrayConcat(\"items\", [field(\"newItems\"), field(\"otherItems\")]);\n * ```\n *\n * @param firstArrayField - The first array to concatenate to.\n * @param secondArray - The second array expression or array literal to concatenate to.\n * @param otherArrays - Optional additional array expressions or array literals to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated array.\n */\nexport function arrayConcat(\n  firstArrayField: string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression;\n\nexport function arrayConcat(\n  firstArray: Expression | string,\n  secondArray: Expression | unknown[],\n  ...otherArrays: Array<Expression | unknown[]>\n): FunctionExpression {\n  const exprValues = otherArrays.map(element => valueToDefaultExpr(element));\n  return fieldOrExpression(firstArray).arrayConcat(\n    fieldOrExpression(secondArray),\n    ...exprValues\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(field(\"colors\"), field(\"selectedColor\"));\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(field(\"colors\"), \"red\");\n * ```\n *\n * @param array - The array expression to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  array: Expression,\n  element: unknown\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific element.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains the value of field 'selectedColor'\n * arrayContains(\"colors\", field(\"selectedColor\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains a specific value.\n *\n * @example\n * ```typescript\n * // Check if the 'colors' array contains \"red\"\n * arrayContains(\"colors\", \"red\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param element - The element to search for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains' comparison.\n */\nexport function arrayContains(\n  fieldName: string,\n  element: unknown\n): BooleanExpression;\nexport function arrayContains(\n  array: Expression | string,\n  element: unknown\n): BooleanExpression {\n  const arrayExpr = fieldOrExpression(array);\n  const elementExpr = valueToDefaultExpr(element);\n  return arrayExpr.arrayContains(elementExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", [field(\"cate1\"), \"Science\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'categories' array contains either values from field \"cate1\" or \"Science\"\n * arrayContainsAny(field(\"categories\"), array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param array - The array expression to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  array: Expression,\n  values: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains any of the specified\n * elements.\n *\n * @example\n * ```typescript\n * // Check if the 'groups' array contains either the value from the 'userGroup' field\n * // or the value \"guest\"\n * arrayContainsAny(\"categories\", array([field(\"cate1\"), \"Science\"]));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - An expression that evaluates to an array, whose elements to check for in the array field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_any' comparison.\n */\nexport function arrayContainsAny(\n  fieldName: string,\n  values: Expression\n): BooleanExpression;\nexport function arrayContainsAny(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param values - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an array expression contains all the specified elements.\n *\n * @example\n * ```typescript\n * // Check if the \"tags\" array contains all of the values: \"SciFi\", \"Adventure\", and the value from field \"tag1\"\n * arrayContainsAll(field(\"tags\"), [field(\"tag1\"), constant(\"SciFi\"), \"Adventure\"]);\n * ```\n *\n * @param array - The array expression to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  array: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's array value contains all the specified values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'tags' array contains both of the values from field 'tag1', the value \"SciFi\", and \"Adventure\"\n * arrayContainsAll(\"tags\", [field(\"tag1\"), \"SciFi\", \"Adventure\"]);\n * ```\n *\n * @param fieldName - The field name to check.\n * @param arrayExpression - The elements to check for in the array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'array_contains_all' comparison.\n */\nexport function arrayContainsAll(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function arrayContainsAll(\n  array: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(array).arrayContainsAll(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array in a specified field.\n *\n * @example\n * ```typescript\n * // Get the number of items in field 'cart'\n * arrayLength('cart');\n * ```\n *\n * @param fieldName - The name of the field containing an array to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of an array expression.\n *\n * @example\n * ```typescript\n * // Get the number of items in the 'cart' array\n * arrayLength(field(\"cart\"));\n * ```\n *\n * @param array - The array expression to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function arrayLength(array: Expression): FunctionExpression;\nexport function arrayLength(array: Expression | string): FunctionExpression {\n  return fieldOrExpression(array).arrayLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression, when evaluated, is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(field(\"category\"), [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is equal to any of the provided values.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is set to a value in the disabledCategories field\n * equalAny(field(\"category\"), field('disabledCategories'));\n * ```\n *\n * @param expression - The expression whose results to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  expression: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [constant(\"Electronics\"), field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is equal to any of the provided values or\n * expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'category' field is either \"Electronics\" or value of field 'primaryType'\n * equalAny(\"category\", [\"Electronics\", field(\"primaryType\")]);\n * ```\n *\n * @param fieldName - The field to compare.\n * @param arrayExpression - An expression that evaluates to an array, whose elements to check for equality to the input field.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'IN' comparison.\n */\nexport function equalAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\nexport function equalAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).equalAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of 'rejectedStatus'\n * notEqualAny(\"status\", [constant(\"pending\"), field(\"rejectedStatus\")]);\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param values - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  values: Array<Expression | unknown>\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if an expression is not equal to any of the provided values\n * or expressions.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is neither \"pending\" nor the value of the field 'rejectedStatus'\n * notEqualAny(field(\"status\"), [\"pending\", field(\"rejectedStatus\")]);\n * ```\n *\n * @param element - The expression to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  element: Expression,\n  arrayExpression: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value is not equal to any of the values in the evaluated expression.\n *\n * @example\n * ```typescript\n * // Check if the 'status' field is not equal to any value in the field 'rejectedStatuses'\n * notEqualAny(\"status\", field(\"rejectedStatuses\"));\n * ```\n *\n * @param fieldName - The field name to compare.\n * @param arrayExpression - The values to check against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'NOT IN' comparison.\n */\nexport function notEqualAny(\n  fieldName: string,\n  arrayExpression: Expression\n): BooleanExpression;\n\nexport function notEqualAny(\n  element: Expression | string,\n  values: unknown[] | Expression\n): BooleanExpression {\n  // @ts-ignore implementation accepts both types\n  return fieldOrExpression(element).notEqualAny(values);\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'XOR' (exclusive OR) operation on multiple BooleanExpressions.\n *\n * @example\n * ```typescript\n * // Check if only one of the conditions is true: 'age' greater than 18, 'city' is \"London\",\n * // or 'status' is \"active\".\n * const condition = xor(\n *     greaterThan(\"age\", 18),\n *     equal(\"city\", \"London\"),\n *     equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first condition.\n * @param second - The second condition.\n * @param additionalConditions - Additional conditions to 'XOR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'XOR' operation.\n */\nexport function xor(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...additionalConditions: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'xor',\n    [first, second, ...additionalConditions],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates a conditional expression that evaluates to a 'then' expression if a condition is true\n * and an 'else' expression if the condition is false.\n *\n * @example\n * ```typescript\n * // If 'age' is greater than 18, return \"Adult\"; otherwise, return \"Minor\".\n * conditional(\n *     greaterThan(\"age\", 18), constant(\"Adult\"), constant(\"Minor\"));\n * ```\n *\n * @param condition - The condition to evaluate.\n * @param thenExpr - The expression to evaluate if the condition is true.\n * @param elseExpr - The expression to evaluate if the condition is false.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the conditional expression.\n */\nexport function conditional(\n  condition: BooleanExpression,\n  thenExpr: Expression,\n  elseExpr: Expression\n): FunctionExpression {\n  return new FunctionExpression(\n    'conditional',\n    [condition, thenExpr, elseExpr],\n    'conditional'\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that negates a filter condition.\n *\n * @example\n * ```typescript\n * // Find documents where the 'completed' field is NOT true\n * not(equal(\"completed\", true));\n * ```\n *\n * @param booleanExpr - The filter condition to negate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the negated filter condition.\n */\nexport function not(booleanExpr: BooleanExpression): BooleanExpression {\n  return booleanExpr.not();\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000\n * logicalMaximum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the largest value between multiple input\n * expressions or literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the largest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMaximum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical maximum operation.\n */\nexport function logicalMaximum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMaximum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMaximum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between multiple input\n * expressions and literal values. Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(field(\"field1\"), field(\"field2\"), 1000);\n * ```\n *\n * @param first - The first operand expression.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the smallest value between a field's value\n * and other input expressions or literal values.\n * Based on Firestore's value type ordering.\n *\n * @example\n * ```typescript\n * // Returns the smallest value between the 'field1' field, the 'field2' field,\n * // and 1000.\n * logicalMinimum(\"field1\", field(\"field2\"), 1000);\n * ```\n *\n * @param fieldName - The first operand field name.\n * @param second - The second expression or literal.\n * @param others - Optional additional expressions or literals.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical minimum operation.\n */\nexport function logicalMinimum(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function logicalMinimum(\n  first: Expression | string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return fieldOrExpression(first).logicalMinimum(\n    valueToDefaultExpr(second),\n    ...others.map(value => valueToDefaultExpr(value))\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(field(\"phoneNumber\"));\n * ```\n *\n * @param value - An expression evaluates to the name of the field to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(value: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field exists.\n *\n * @example\n * ```typescript\n * // Check if the document has a field named \"phoneNumber\"\n * exists(\"phoneNumber\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'exists' check.\n */\nexport function exists(fieldName: string): BooleanExpression;\nexport function exists(valueOrField: Expression | string): BooleanExpression {\n  return fieldOrExpression(valueOrField).exists();\n}\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * reverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function reverse(field: string): FunctionExpression;\nexport function reverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).reverse();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the byte length of a string in UTF-8, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(field(\"myString\"));\n * ```\n *\n * @param expr - The expression representing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a string represented by a field in UTF-8 bytes, or just the length of a Blob.\n *\n * @example\n * ```typescript\n * // Calculate the length of the 'myString' field in bytes.\n * byteLength(\"myString\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string in bytes.\n */\nexport function byteLength(fieldName: string): FunctionExpression;\nexport function byteLength(expr: Expression | string): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.byteLength();\n}\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(\"myArray\");\n * ```\n *\n * @param fieldName - The name of the field to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses an array.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myArray' field.\n * arrayReverse(field(\"myArray\"));\n * ```\n *\n * @param arrayExpression - An expression evaluating to an array value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed array.\n */\nexport function arrayReverse(arrayExpression: Expression): FunctionExpression;\nexport function arrayReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arrayReverse();\n}\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of 2.\n * exp(constant(2));\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes e to the power of the expression's result.\n *\n * @example\n * ```typescript\n * // Compute e to the power of the 'value' field.\n * exp('value');\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the exp of the numeric value.\n */\nexport function exp(fieldName: string): FunctionExpression;\n\nexport function exp(\n  expressionOrFieldName: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expressionOrFieldName).exp();\n}\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to compute the ceiling of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the ceiling of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the ceiling of the 'price' field.\n * ceil(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the ceiling will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the ceiling of the numeric value.\n */\nexport function ceil(expression: Expression): FunctionExpression;\nexport function ceil(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ceil();\n}\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param expr - The expression to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the floor of a numeric value.\n *\n * @param fieldName - The name of the field to compute the floor of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the floor of the numeric value.\n */\nexport function floor(fieldName: string): FunctionExpression;\nexport function floor(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).floor();\n}\n\n/**\n * @beta\n * Creates an aggregation that counts the number of distinct values of a field.\n *\n * @param expr - The expression or field to count distinct values of.\n * @returns A new `AggregateFunction` representing the 'count_distinct' aggregation.\n */\nexport function countDistinct(expr: Expression | string): AggregateFunction {\n  return fieldOrExpression(expr).countDistinct();\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string field in UTF8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the character length of a string expression in UTF-8.\n *\n * @example\n * ```typescript\n * // Get the character length of the 'name' field in UTF-8.\n * strLength(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to calculate the length of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the string.\n */\nexport function charLength(stringExpression: Expression): FunctionExpression;\nexport function charLength(value: Expression | string): FunctionExpression {\n  const valueExpr = fieldOrExpression(value);\n  return valueExpr.charLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", \"%guide%\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison against a\n * field.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(\"title\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(fieldName: string, pattern: Expression): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), \"%guide%\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that performs a case-sensitive wildcard string comparison.\n *\n * @example\n * ```typescript\n * // Check if the 'title' field contains the string \"guide\"\n * like(field(\"title\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The pattern to search for. You can use \"%\" as a wildcard character.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'like' comparison.\n */\nexport function like(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function like(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.like(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", \"(?i)example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified regular expression as\n * a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(\"description\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), \"(?i)example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified regular\n * expression as a substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\" (case-insensitive)\n * regexContains(field(\"description\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param pattern - The regular expression to use for the search.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function regexContains(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexContains(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexContains(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that returns the first substring of a string field that matches a\n * specified regular expression.\n *\n * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n *\n * @example\n * ```typescript\n * // Extract the domain name from an email field\n * regexFind(\"email\", \"@[A-Za-z0-9.-]+\");\n * ```\n *\n * @param fieldName - The name of the field containing the string to search.\n * @param pattern - The regular expression to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression find function.\n */\nexport function regexFind(\n  fieldName: string,\n  pattern: string\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the first substring of a string field that matches a\n * specified regular expression.\n *\n * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n *\n * @example\n * ```typescript\n * // Extract a substring from 'email' based on a pattern stored in another field\n * regexFind(\"email\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string to search.\n * @param pattern - The regular expression to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression find function.\n */\nexport function regexFind(\n  fieldName: string,\n  pattern: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the first substring of a string expression that matches\n * a specified regular expression.\n *\n * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n *\n * @example\n * ```typescript\n * // Extract the domain from a lower-cased email address\n * regexFind(field(\"email\"), \"@[A-Za-z0-9.-]+\");\n * ```\n *\n * @param stringExpression - The expression representing the string to search.\n * @param pattern - The regular expression to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression find function.\n */\nexport function regexFind(\n  stringExpression: Expression,\n  pattern: string\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that returns the first substring of a string expression that matches\n * a specified regular expression.\n *\n * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n *\n * @example\n * ```typescript\n * // Extract a substring based on a dynamic pattern field\n * regexFind(field(\"email\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to search.\n * @param pattern - The regular expression to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression find function.\n */\nexport function regexFind(\n  stringExpression: Expression,\n  pattern: Expression\n): FunctionExpression;\nexport function regexFind(\n  left: Expression | string,\n  pattern: Expression | string\n): FunctionExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexFind(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that evaluates to a list of all substrings in a string field that\n * match a specified regular expression.\n *\n * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n *\n * @example\n * ```typescript\n * // Extract all hashtags from a post content field\n * regexFindAll(\"content\", \"#[A-Za-z0-9_]+\");\n * ```\n *\n * @param fieldName - The name of the field containing the string to search.\n * @param pattern - The regular expression to search for.\n * @returns A new {@link @firebase/firestore/pipelines#FunctionExpression} that evaluates to an array of matched substrings.\n */\nexport function regexFindAll(\n  fieldName: string,\n  pattern: string\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that evaluates to a list of all substrings in a string field that\n * match a specified regular expression.\n *\n * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n *\n * @example\n * ```typescript\n * // Extract all matches from 'content' based on a pattern stored in another field\n * regexFindAll(\"content\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string to search.\n * @param pattern - The regular expression to search for.\n * @returns A new {@link @firebase/firestore/pipelines#FunctionExpression} that evaluates to an array of matched substrings.\n */\nexport function regexFindAll(\n  fieldName: string,\n  pattern: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that evaluates to a list of all substrings in a string expression\n * that match a specified regular expression.\n *\n * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n *\n * @example\n * ```typescript\n * // Extract all mentions from a lower-cased comment\n * regexFindAll(field(\"comment\"), \"@[A-Za-z0-9_]+\");\n * ```\n *\n * @param stringExpression - The expression representing the string to search.\n * @param pattern - The regular expression to search for.\n * @returns A new {@link @firebase/firestore/pipelines#FunctionExpression} that evaluates to an array of matched substrings.\n */\nexport function regexFindAll(\n  stringExpression: Expression,\n  pattern: string\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that evaluates to a list of all substrings in a string expression\n * that match a specified regular expression.\n *\n * This expression uses the {@link https://github.com/google/re2/wiki/Syntax | RE2} regular expression syntax.\n *\n * @example\n * ```typescript\n * // Extract all matches based on a dynamic pattern expression\n * regexFindAll(field(\"comment\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to search.\n * @param pattern - The regular expression to search for.\n * @returns A new {@link @firebase/firestore/pipelines#FunctionExpression} that evaluates to an array of matched substrings.\n */\nexport function regexFindAll(\n  stringExpression: Expression,\n  pattern: Expression\n): FunctionExpression;\nexport function regexFindAll(\n  left: Expression | string,\n  pattern: Expression | string\n): FunctionExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexFindAll(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field matches a specified regular expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(\"email\", field(\"pattern\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  fieldName: string,\n  pattern: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\");\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression matches a specified regular\n * expression.\n *\n * @example\n * ```typescript\n * // Check if the 'email' field matches a valid email pattern\n * regexMatch(field(\"email\"), field(\"pattern\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to match against.\n * @param pattern - The regular expression to use for the match.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the regular expression match.\n */\nexport function regexMatch(\n  stringExpression: Expression,\n  pattern: Expression\n): BooleanExpression;\nexport function regexMatch(\n  left: Expression | string,\n  pattern: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const patternExpr = valueToDefaultExpr(pattern);\n  return leftExpr.regexMatch(patternExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(\"description\", \"example\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string field contains a substring specified by an expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(\"description\", field(\"keyword\"));\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  fieldName: string,\n  substring: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a specified substring.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains \"example\".\n * stringContains(field(\"description\"), \"example\");\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression contains a substring specified by another expression.\n *\n * @example\n * ```typescript\n * // Check if the 'description' field contains the value of the 'keyword' field.\n * stringContains(field(\"description\"), field(\"keyword\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to perform the comparison on.\n * @param substring - The expression representing the substring to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'contains' comparison.\n */\nexport function stringContains(\n  stringExpression: Expression,\n  substring: Expression\n): BooleanExpression;\nexport function stringContains(\n  left: Expression | string,\n  substring: Expression | string\n): BooleanExpression {\n  const leftExpr = fieldOrExpression(left);\n  const substringExpr = valueToDefaultExpr(substring);\n  return leftExpr.stringContains(substringExpr);\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'name' field starts with \"Mr.\"\n * startsWith(\"name\", \"Mr.\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the 'fullName' field starts with the value of the 'firstName' field\n * startsWith(\"fullName\", field(\"firstName\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param prefix - The expression representing the prefix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  fieldName: string,\n  prefix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), \"Mr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression starts with a given prefix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields starts with \"Mr.\"\n * startsWith(field(\"fullName\"), field(\"prefix\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param prefix - The prefix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'starts with' comparison.\n */\nexport function startsWith(\n  stringExpression: Expression,\n  prefix: Expression\n): BooleanExpression;\nexport function startsWith(\n  expr: Expression | string,\n  prefix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).startsWith(valueToDefaultExpr(prefix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'filename' field ends with \".txt\"\n * endsWith(\"filename\", \".txt\");\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(fieldName: string, suffix: string): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a field's value ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the 'url' field ends with the value of the 'extension' field\n * endsWith(\"url\", field(\"extension\"));\n * ```\n *\n * @param fieldName - The field name to check.\n * @param suffix - The expression representing the postfix.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  fieldName: string,\n  suffix: Expression\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), \"Jr.\");\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: string\n): BooleanExpression;\n\n/**\n * @beta\n *\n * Creates an expression that checks if a string expression ends with a given postfix.\n *\n * @example\n * ```typescript\n * // Check if the result of concatenating 'firstName' and 'lastName' fields ends with \"Jr.\"\n * endsWith(field(\"fullName\"), constant(\"Jr.\"));\n * ```\n *\n * @param stringExpression - The expression to check.\n * @param suffix - The postfix to check for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the 'ends with' comparison.\n */\nexport function endsWith(\n  stringExpression: Expression,\n  suffix: Expression\n): BooleanExpression;\nexport function endsWith(\n  expr: Expression | string,\n  suffix: Expression | string\n): BooleanExpression {\n  return fieldOrExpression(expr).endsWith(valueToDefaultExpr(suffix));\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(\"name\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to lowercase.\n *\n * @example\n * ```typescript\n * // Convert the 'name' field to lowercase\n * toLower(field(\"name\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to lowercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the lowercase string.\n */\nexport function toLower(stringExpression: Expression): FunctionExpression;\nexport function toLower(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toLower();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a string field to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUpper(\"title\");\n * ```\n *\n * @param fieldName - The name of the field containing the string.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a string expression to uppercase.\n *\n * @example\n * ```typescript\n * // Convert the 'title' field to uppercase\n * toUppercase(field(\"title\"));\n * ```\n *\n * @param stringExpression - The expression representing the string to convert to uppercase.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the uppercase string.\n */\nexport function toUpper(stringExpression: Expression): FunctionExpression;\nexport function toUpper(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).toUpper();\n}\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing whitespace from a string or byte array.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(\"userInput\");\n *\n * // Trim quotes from the 'userInput' field\n * trim(\"userInput\", '\"');\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string.\n */\nexport function trim(\n  fieldName: string,\n  valueToTrim?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that removes leading and trailing characters from a string or byte array expression.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the 'userInput' field\n * trim(field(\"userInput\"));\n *\n * // Trim quotes from the 'userInput' field\n * trim(field(\"userInput\"), '\"');\n * ```\n *\n * @param stringExpression - The expression representing the string or byte array to trim.\n * @param valueToTrim - Optional This parameter is treated as a set of characters or bytes that will be\n * trimmed from the input. If not specified, then whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string or byte array.\n */\nexport function trim(\n  stringExpression: Expression,\n  valueToTrim?: string | Expression\n): FunctionExpression;\nexport function trim(\n  expr: Expression | string,\n  valueToTrim?: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(expr).trim(valueToTrim);\n}\n\n/**\n * @beta\n * Trims whitespace or a specified set of characters/bytes from the beginning of a string or byte array.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the beginning of the 'userInput' field\n * ltrim(field(\"userInput\"));\n *\n * // Trim quotes from the beginning of the 'userInput' field\n * ltrim(field(\"userInput\"), '\"');\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param valueToTrim - Optional. A string or byte array containing the characters/bytes to trim.\n * If not specified, whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string or byte array.\n */\nexport function ltrim(\n  fieldName: string,\n  valueToTrim?: string | Expression | Bytes\n): FunctionExpression;\n\n/**\n * @beta\n * Trims whitespace or a specified set of characters/bytes from the beginning of a string or byte array.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the beginning of the 'userInput' field\n * ltrim(field(\"userInput\"));\n *\n * // Trim quotes from the beginning of the 'userInput' field\n * ltrim(field(\"userInput\"), '\"');\n * ```\n *\n * @param expression - The expression representing the string or byte array.\n * @param valueToTrim - Optional. A string or byte array containing the characters/bytes to trim.\n * If not specified, whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string or byte array.\n */\nexport function ltrim(\n  expression: Expression,\n  valueToTrim?: string | Expression | Bytes\n): FunctionExpression;\nexport function ltrim(\n  expr: Expression | string,\n  valueToTrim?: string | Expression | Bytes\n): FunctionExpression {\n  return fieldOrExpression(expr).ltrim(valueToTrim);\n}\n\n/**\n * @beta\n * Trims whitespace or a specified set of characters/bytes from the end of a string or byte array.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the end of the 'userInput' field\n * rtrim(field(\"userInput\"));\n *\n * // Trim quotes from the end of the 'userInput' field\n * rtrim(field(\"userInput\"), '\"');\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param valueToTrim - Optional. A string or byte array containing the characters/bytes to trim.\n * If not specified, whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string or byte array.\n */\nexport function rtrim(\n  fieldName: string,\n  valueToTrim?: string | Expression | Bytes\n): FunctionExpression;\n\n/**\n * @beta\n * Trims whitespace or a specified set of characters/bytes from the end of a string or byte array.\n *\n * @example\n * ```typescript\n * // Trim whitespace from the end of the 'userInput' field\n * rtrim(field(\"userInput\"));\n *\n * // Trim quotes from the end of the 'userInput' field\n * rtrim(field(\"userInput\"), '\"');\n * ```\n *\n * @param expression - The expression representing the string or byte array.\n * @param valueToTrim - Optional. A string or byte array containing the characters/bytes to trim.\n * If not specified, whitespace will be trimmed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the trimmed string or byte array.\n */\nexport function rtrim(\n  expression: Expression,\n  valueToTrim?: string | Expression | Bytes\n): FunctionExpression;\nexport function rtrim(\n  expr: Expression | string,\n  valueToTrim?: string | Expression | Bytes\n): FunctionExpression {\n  return fieldOrExpression(expr).rtrim(valueToTrim);\n}\n\n/**\n * @beta\n * Creates an expression that returns the data type of the data in the specified field.\n *\n * @remarks\n * String inputs passed iteratively to this global function act as `field()` path lookups.\n * If you wish to pass a string literal value, it must be wrapped: `type(constant(\"my_string\"))`.\n *\n * @example\n * ```typescript\n * // Get the data type of the value in field 'title'\n * type('title')\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(fieldName: string): FunctionExpression;\n/**\n * @beta\n * Creates an expression that returns the data type of an expression's result.\n *\n * @example\n * ```typescript\n * // Get the data type of a conditional expression\n * type(conditional(exists('foo'), constant(1), constant(true)))\n * ```\n *\n * @returns A new `Expression` representing the data type.\n */\nexport function type(expression: Expression): FunctionExpression;\nexport function type(\n  fieldNameOrExpression: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).type();\n}\n\n/**\n * @beta\n * Creates an expression that checks if the value in the specified field is of the given type.\n *\n * @remarks Null or undefined fields evaluate to skip/error. Use `ifAbsent()` / `isAbsent()` to evaluate missing data.\n *\n * @example\n * ```typescript\n * // Check if the 'price' field is a floating point number (evaluating to true inside pipeline conditionals)\n * isType('price', 'float64');\n * ```\n *\n * @param fieldName - The name of the field to check.\n * @param type - The type to check for.\n * @returns A new `BooleanExpression` that evaluates to true if the field's value is of the given type, false otherwise.\n */\nexport function isType(fieldName: string, type: Type): BooleanExpression;\n\n/**\n * @beta\n * Creates an expression that checks if the result of an expression is of the given type.\n *\n * @remarks Null or undefined fields evaluate to skip/error. Use `ifAbsent()` / `isAbsent()` to evaluate missing data.\n *\n * @example\n * ```typescript\n * // Check if the result of a calculation is a number\n * isType(add('count', 1), 'number')\n * ```\n *\n * @param expression - The expression to check.\n * @param type - The type to check for.\n * @returns A new `BooleanExpression` that evaluates to true if the expression's result is of the given type, false otherwise.\n */\nexport function isType(expression: Expression, type: Type): BooleanExpression;\nexport function isType(\n  fieldNameOrExpression: string | Expression,\n  type: Type\n): BooleanExpression {\n  return fieldOrExpression(fieldNameOrExpression).isType(type);\n}\n\n/**\n * @beta\n *\n * Creates an expression that concatenates string functions, fields or constants together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(\"firstName\", \" \", field(\"lastName\"));\n * ```\n *\n * @param fieldName - The field name containing the initial string value.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  fieldName: string,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates string expressions together.\n *\n * @example\n * ```typescript\n * // Combine the 'firstName', \" \", and 'lastName' fields into a single string\n * stringConcat(field(\"firstName\"), \" \", field(\"lastName\"));\n * ```\n *\n * @param firstString - The initial string expression to concatenate to.\n * @param secondString - An expression or string literal to concatenate.\n * @param otherStrings - Optional additional expressions or literals (typically strings) to concatenate.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the concatenated string.\n */\nexport function stringConcat(\n  firstString: Expression,\n  secondString: Expression | string,\n  ...otherStrings: Array<Expression | string>\n): FunctionExpression;\nexport function stringConcat(\n  first: string | Expression,\n  second: string | Expression,\n  ...elements: Array<string | Expression>\n): FunctionExpression {\n  return fieldOrExpression(first).stringConcat(\n    valueToDefaultExpr(second),\n    ...elements.map(valueToDefaultExpr)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that finds the index of the first occurrence of a substring or byte sequence.\n *\n * @example\n * ```typescript\n * // Find the index of \"foo\" in the 'text' field\n * stringIndexOf(\"text\", \"foo\");\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param search - The substring or byte sequence to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the index of the first occurrence.\n */\nexport function stringIndexOf(\n  fieldName: string,\n  search: string | Expression | Bytes\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that finds the index of the first occurrence of a substring or byte sequence.\n *\n * @example\n * ```typescript\n * // Find the index of \"foo\" in the 'text' field\n * stringIndexOf(field(\"text\"), \"foo\");\n * ```\n *\n * @param expression - The expression representing the string or byte array.\n * @param search - The substring or byte sequence to search for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the index of the first occurrence.\n */\nexport function stringIndexOf(\n  expression: Expression,\n  search: string | Expression | Bytes\n): FunctionExpression;\nexport function stringIndexOf(\n  expr: Expression | string,\n  search: string | Expression | Bytes\n): FunctionExpression {\n  return fieldOrExpression(expr).stringIndexOf(search);\n}\n\n/**\n * @beta\n * Creates an expression that repeats a string or byte array a specified number of times.\n *\n * @example\n * ```typescript\n * // Repeat the 'label' field 3 times\n * stringRepeat(\"label\", 3);\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param repetitions - The number of times to repeat the string or byte array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the repeated string or byte array.\n */\nexport function stringRepeat(\n  fieldName: string,\n  repetitions: number | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that repeats a string or byte array a specified number of times.\n *\n * @example\n * ```typescript\n * // Repeat the 'label' field 3 times\n * stringRepeat(field(\"label\"), 3);\n * ```\n *\n * @param expression - The expression representing the string or byte array.\n * @param repetitions - The number of times to repeat the string or byte array.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the repeated string or byte array.\n */\nexport function stringRepeat(\n  expression: Expression,\n  repetitions: number | Expression\n): FunctionExpression;\nexport function stringRepeat(\n  expr: Expression | string,\n  repetitions: number | Expression\n): FunctionExpression {\n  return fieldOrExpression(expr).stringRepeat(repetitions);\n}\n\n/**\n * @beta\n * Creates an expression that replaces all occurrences of a substring or byte sequence with a replacement.\n *\n * @example\n * ```typescript\n * // Replace all occurrences of \"foo\" with \"bar\" in the 'text' field\n * stringReplaceAll(\"text\", \"foo\", \"bar\");\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param find - The substring or byte sequence to search for.\n * @param replacement - The replacement string or byte sequence.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the string or byte array with replacements.\n */\nexport function stringReplaceAll(\n  fieldName: string,\n  find: string | Expression | Bytes,\n  replacement: string | Expression | Bytes\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that replaces all occurrences of a substring or byte sequence with a replacement.\n *\n * @example\n * ```typescript\n * // Replace all occurrences of \"foo\" with \"bar\" in the 'text' field\n * stringReplaceAll(field(\"text\"), \"foo\", \"bar\");\n * ```\n *\n * @param expression - The expression representing the string or byte array.\n * @param find - The substring or byte sequence to search for.\n * @param replacement - The replacement string or byte sequence.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the string or byte array with replacements.\n */\nexport function stringReplaceAll(\n  expression: Expression,\n  find: string | Expression | Bytes,\n  replacement: string | Expression | Bytes\n): FunctionExpression;\nexport function stringReplaceAll(\n  expr: Expression | string,\n  find: string | Expression | Bytes,\n  replacement: string | Expression | Bytes\n): FunctionExpression {\n  return fieldOrExpression(expr).stringReplaceAll(find, replacement);\n}\n\n/**\n * @beta\n * Creates an expression that replaces the first occurrence of a substring or byte sequence with a replacement.\n *\n * @example\n * ```typescript\n * // Replace the first occurrence of \"foo\" with \"bar\" in the 'text' field\n * stringReplaceOne(\"text\", \"foo\", \"bar\");\n * ```\n *\n * @param fieldName - The name of the field containing the string or byte array.\n * @param find - The substring or byte sequence to search for.\n * @param replacement - The replacement string or byte sequence.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the string or byte array with the replacement.\n */\nexport function stringReplaceOne(\n  fieldName: string,\n  find: string | Expression | Bytes,\n  replacement: string | Expression | Bytes\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that replaces the first occurrence of a substring or byte sequence with a replacement.\n *\n * @example\n * ```typescript\n * // Replace the first occurrence of \"foo\" with \"bar\" in the 'text' field\n * stringReplaceOne(field(\"text\"), \"foo\", \"bar\");\n * ```\n *\n * @param expression - The expression representing the string or byte array.\n * @param find - The substring or byte sequence to search for.\n * @param replacement - The replacement string or byte sequence.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the string or byte array with the replacement.\n */\nexport function stringReplaceOne(\n  expression: Expression,\n  find: string | Expression | Bytes,\n  replacement: string | Expression | Bytes\n): FunctionExpression;\nexport function stringReplaceOne(\n  expr: Expression | string,\n  find: string | Expression | Bytes,\n  replacement: string | Expression | Bytes\n): FunctionExpression {\n  return fieldOrExpression(expr).stringReplaceOne(find, replacement);\n}\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) field using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(\"address\", \"city\");\n * ```\n *\n * @param fieldName - The field name of the map field.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(fieldName: string, subField: string): FunctionExpression;\n\n/**\n * @beta\n *\n * Accesses a value from a map (object) expression using the provided key.\n *\n * @example\n * ```typescript\n * // Get the 'city' value from the 'address' map field\n * mapGet(field(\"address\"), \"city\");\n * ```\n *\n * @param mapExpression - The expression representing the map.\n * @param subField - The key to access in the map.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the value associated with the given key in the map.\n */\nexport function mapGet(\n  mapExpression: Expression,\n  subField: string\n): FunctionExpression;\nexport function mapGet(\n  fieldOrExpr: string | Expression,\n  subField: string\n): FunctionExpression {\n  return fieldOrExpression(fieldOrExpr).mapGet(subField);\n}\n\n/**\n * @beta\n * Creates an expression that returns a new map with the specified entries added or updated.\n *\n * @remarks\n * This only performs shallow updates to the map. Setting a value to `null`\n * will retain the key with a `null` value. To remove a key entirely, use `mapRemove`.\n *\n * @example\n * ```typescript\n * // Set the 'city' to 'San Francisco' in the 'address' map field\n * mapSet(\"address\", \"city\", \"San Francisco\");\n * ```\n *\n * @param mapField - The map field to set entries in.\n * @param key - The key to set. Must be a string or a constant string expression.\n * @param value - The value to set.\n * @param moreKeyValues - Additional key-value pairs to set.\n * @returns A new `Expression` representing the map with the entries set.\n */\nexport function mapSet(\n  mapField: string,\n  key: string | Expression,\n  value: unknown,\n  ...moreKeyValues: unknown[]\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns a new map with the specified entries added or updated.\n *\n * @remarks\n * This only performs shallow updates to the map. Setting a value to `null`\n * will retain the key with a `null` value. To remove a key entirely, use `mapRemove`.\n *\n * @example\n * ```typescript\n * // Set the 'city' to \"San Francisco\"\n * mapSet(map({\"state\": \"California\"}), \"city\", \"San Francisco\");\n * ```\n *\n * @param mapExpression - The expression representing the map.\n * @param key - The key to set. Must be a string or a constant string expression.\n * @param value - The value to set.\n * @param moreKeyValues - Additional key-value pairs to set.\n * @returns A new `Expression` representing the map with the entries set.\n */\nexport function mapSet(\n  mapExpression: Expression,\n  key: string | Expression,\n  value: unknown,\n  ...moreKeyValues: unknown[]\n): FunctionExpression;\nexport function mapSet(\n  fieldOrExpr: string | Expression,\n  key: string | Expression,\n  value: unknown,\n  ...moreKeyValues: unknown[]\n): FunctionExpression {\n  return fieldOrExpression(fieldOrExpr).mapSet(key, value, ...moreKeyValues);\n}\n\n/**\n * @beta\n * Creates an expression that returns the keys of a map.\n *\n * @remarks\n * While the backend generally preserves insertion order, relying on the\n * order of the output array is not guaranteed and should be avoided.\n *\n * @example\n * ```typescript\n * // Get the keys of the 'address' map field\n * mapKeys(\"address\");\n * ```\n *\n * @param mapField - The map field to get the keys of.\n * @returns A new `Expression` representing the keys of the map.\n */\nexport function mapKeys(mapField: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the keys of a map.\n *\n * @remarks\n * While the backend generally preserves insertion order, relying on the\n * order of the output array is not guaranteed and should be avoided.\n *\n * @example\n * ```typescript\n * // Get the keys of the map expression\n * mapKeys(map({\"city\": \"San Francisco\"}));\n * ```\n *\n * @param mapExpression - The expression representing the map to get the keys of.\n * @returns A new `Expression` representing the keys of the map.\n */\nexport function mapKeys(mapExpression: Expression): FunctionExpression;\nexport function mapKeys(fieldOrExpr: string | Expression): FunctionExpression {\n  return fieldOrExpression(fieldOrExpr).mapKeys();\n}\n\n/**\n * @beta\n * Creates an expression that returns the values of a map.\n *\n * @remarks\n * While the backend generally preserves insertion order, relying on the\n * order of the output array is not guaranteed and should be avoided.\n *\n * @example\n * ```typescript\n * // Get the values of the 'address' map field\n * mapValues(\"address\");\n * ```\n *\n * @param mapField - The map field to get the values of.\n * @returns A new `Expression` representing the values of the map.\n */\nexport function mapValues(mapField: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the values of a map.\n *\n * @remarks\n * While the backend generally preserves insertion order, relying on the\n * order of the output array is not guaranteed and should be avoided.\n *\n * @example\n * ```typescript\n * // Get the values of the map expression\n * mapValues(map({\"city\": \"San Francisco\"}));\n * ```\n *\n * @param mapExpression - The expression representing the map to get the values of.\n * @returns A new `Expression` representing the values of the map.\n */\nexport function mapValues(mapExpression: Expression): FunctionExpression;\nexport function mapValues(\n  fieldOrExpr: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldOrExpr).mapValues();\n}\n\n/**\n * @beta\n * Creates an expression that returns the entries of a map as an array of maps,\n * where each map contains a `\"k\"` property for the key and a `\"v\"` property for the value.\n * For example: `[{ k: \"key1\", v: \"value1\" }, ...]`.\n *\n * @remarks\n * While the backend generally preserves insertion order, relying on the\n * order of the output array is not guaranteed and should be avoided.\n *\n * @example\n * ```typescript\n * // Get the entries of the 'address' map field\n * mapEntries(\"address\");\n * ```\n *\n * @param mapField - The map field to get the entries of.\n * @returns A new `Expression` representing the entries of the map.\n */\nexport function mapEntries(mapField: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the entries of a map as an array of maps,\n * where each map contains a `\"k\"` property for the key and a `\"v\"` property for the value.\n * For example: `[{ k: \"key1\", v: \"value1\" }, ...]`.\n *\n * @remarks\n * While the backend generally preserves insertion order, relying on the\n * order of the output array is not guaranteed and should be avoided.\n *\n * @example\n * ```typescript\n * // Get the entries of the map expression\n * mapEntries(map({\"city\": \"San Francisco\"}));\n * ```\n *\n * @param mapExpression - The expression representing the map to get the entries of.\n * @returns A new `Expression` representing the entries of the map.\n */\nexport function mapEntries(mapExpression: Expression): FunctionExpression;\nexport function mapEntries(\n  fieldOrExpr: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldOrExpr).mapEntries();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the total number of stage inputs.\n *\n * @example\n * ```typescript\n * // Count the total number of input documents\n * countAll().as(\"totalDocument\");\n * ```\n *\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'countAll' aggregation.\n */\nexport function countAll(): AggregateFunction {\n  return AggregateFunction._create('count', [], 'count');\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that counts the number of stage inputs with valid evaluations of the\n * provided expression.\n *\n * @example\n * ```typescript\n * // Count the number of items where the price is greater than 10\n * count(field(\"price\").greaterThan(10)).as(\"expensiveItemCount\");\n * ```\n *\n * @param expression - The expression to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n * Creates an aggregation that counts the number of stage inputs where the input field exists.\n *\n * @example\n * ```typescript\n * // Count the total number of products\n * count(\"productId\").as(\"totalProducts\");\n * ```\n *\n * @param fieldName - The name of the field to count.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'count' aggregation.\n */\nexport function count(fieldName: string): AggregateFunction;\nexport function count(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).count();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of values from an expression across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(field(\"orderAmount\")).as(\"totalRevenue\");\n * ```\n *\n * @param expression - The expression to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the sum of a field's values across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Calculate the total revenue from a set of orders\n * sum(\"orderAmount\").as(\"totalRevenue\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to sum up.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'sum' aggregation.\n */\nexport function sum(fieldName: string): AggregateFunction;\nexport function sum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).sum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of values from an expression across\n * multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(field(\"age\")).as(\"averageAge\");\n * ```\n *\n * @param expression - The expression representing the values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that calculates the average (mean) of a field's values across multiple\n * stage inputs.\n *\n * @example\n * ```typescript\n * // Calculate the average age of users\n * average(\"age\").as(\"averageAge\");\n * ```\n *\n * @param fieldName - The name of the field containing numeric values to average.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'average' aggregation.\n */\nexport function average(fieldName: string): AggregateFunction;\nexport function average(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).average();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(field(\"price\")).as(\"lowestPrice\");\n * ```\n *\n * @param expression - The expression to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the minimum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the lowest price of all products\n * minimum(\"price\").as(\"lowestPrice\");\n * ```\n *\n * @param fieldName - The name of the field to find the minimum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'minimum' aggregation.\n */\nexport function minimum(fieldName: string): AggregateFunction;\nexport function minimum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).minimum();\n}\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(field(\"score\")).as(\"highestScore\");\n * ```\n *\n * @param expression - The expression to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n *\n * Creates an aggregation that finds the maximum value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the highest score in a leaderboard\n * maximum(\"score\").as(\"highestScore\");\n * ```\n *\n * @param fieldName - The name of the field to find the maximum value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'maximum' aggregation.\n */\nexport function maximum(fieldName: string): AggregateFunction;\nexport function maximum(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).maximum();\n}\n\n/**\n * @beta\n * Creates an aggregation that finds the first value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the first value of the 'rating' field\n * first(field(\"rating\")).as(\"firstRating\");\n * ```\n *\n * @param expression - The expression to find the first value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'first' aggregation.\n */\nexport function first(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n * Creates an aggregation that finds the first value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the first value of the 'rating' field\n * first(\"rating\").as(\"firstRating\");\n * ```\n *\n * @param fieldName - The name of the field to find the first value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'first' aggregation.\n */\nexport function first(fieldName: string): AggregateFunction;\nexport function first(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).first();\n}\n\n/**\n * @beta\n * Creates an aggregation that finds the last value of an expression across multiple stage\n * inputs.\n *\n * @example\n * ```typescript\n * // Find the last value of the 'rating' field\n * last(field(\"rating\")).as(\"lastRating\");\n * ```\n *\n * @param expression - The expression to find the last value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'last' aggregation.\n */\nexport function last(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n * Creates an aggregation that finds the last value of a field across multiple stage inputs.\n *\n * @example\n * ```typescript\n * // Find the last value of the 'rating' field\n * last(\"rating\").as(\"lastRating\");\n * ```\n *\n * @param fieldName - The name of the field to find the last value of.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'last' aggregation.\n */\nexport function last(fieldName: string): AggregateFunction;\nexport function last(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).last();\n}\n\n/**\n * @beta\n * Creates an aggregation that collects all values of an expression across multiple stage\n * inputs into an array.\n *\n * @remarks\n * If the expression resolves to an absent value, it is converted to `null`.\n * The order of elements in the output array is not stable and shouldn't be relied upon.\n *\n * @example\n * ```typescript\n * // Collect all tags from books into an array\n * arrayAgg(field(\"tags\")).as(\"allTags\");\n * ```\n *\n * @param expression - The expression to collect values from.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'array_agg' aggregation.\n */\nexport function arrayAgg(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n * Creates an aggregation that collects all values of a field across multiple stage inputs\n * into an array.\n *\n * @remarks\n * If the expression resolves to an absent value, it is converted to `null`.\n * The order of elements in the output array is not stable and shouldn't be relied upon.\n *\n * @example\n * ```typescript\n * // Collect all tags from books into an array\n * arrayAgg(\"tags\").as(\"allTags\");\n * ```\n *\n * @param fieldName - The name of the field to collect values from.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'array_agg' aggregation.\n */\nexport function arrayAgg(fieldName: string): AggregateFunction;\nexport function arrayAgg(value: Expression | string): AggregateFunction {\n  return fieldOrExpression(value).arrayAgg();\n}\n\n/**\n * @beta\n * Creates an aggregation that collects all distinct values of an expression across multiple stage\n * inputs into an array.\n *\n * @remarks\n * If the expression resolves to an absent value, it is converted to `null`.\n * The order of elements in the output array is not stable and shouldn't be relied upon.\n *\n * @example\n * ```typescript\n * // Collect all distinct tags from books into an array\n * arrayAggDistinct(field(\"tags\")).as(\"allDistinctTags\");\n * ```\n *\n * @param expression - The expression to collect values from.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'array_agg_distinct' aggregation.\n */\nexport function arrayAggDistinct(expression: Expression): AggregateFunction;\n\n/**\n * @beta\n * Creates an aggregation that collects all distinct values of a field across multiple stage inputs\n * into an array.\n *\n * @remarks\n * If the expression resolves to an absent value, it is converted to `null`.\n * The order of elements in the output array is not stable and shouldn't be relied upon.\n *\n * @example\n * ```typescript\n * // Collect all distinct tags from books into an array\n * arrayAggDistinct(\"tags\").as(\"allDistinctTags\");\n * ```\n *\n * @param fieldName - The name of the field to collect values from.\n * @returns A new {@link @firebase/firestore/pipelines#AggregateFunction} representing the 'array_agg_distinct' aggregation.\n */\nexport function arrayAggDistinct(fieldName: string): AggregateFunction;\nexport function arrayAggDistinct(\n  value: Expression | string\n): AggregateFunction {\n  return fieldOrExpression(value).arrayAggDistinct();\n}\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a literal vector value.\n *\n * @example\n * ```typescript\n * // Calculate the Cosine distance between the 'location' field and a target location\n * cosineDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles) or {@link VectorValue} to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(\"userVector\", field(\"itemVector\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between a vector expression and a vector literal.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'location' field and a target location\n * cosineDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Cosine distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the cosine distance between the 'userVector' field and the 'itemVector' field\n * cosineDistance(field(\"userVector\"), field(\"itemVector\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the cosine distance between the two vectors.\n */\nexport function cosineDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function cosineDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.cosineDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between a feature vector and a target vector\n * dotProduct(\"features\", [0.5, 0.8, 0.2]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the dot product distance between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(\"docVector1\", field(\"docVector2\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between a feature vector and a target vector\n * dotProduct(field(\"features\"), [0.5, 0.8, 0.2]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param vector - The other vector (as an array of doubles or VectorValue) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the dot product between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the dot product between two document vectors: 'docVector1' and 'docVector2'\n * dotProduct(field(\"docVector1\"), field(\"docVector2\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to calculate with.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to calculate with.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the dot product between the two vectors.\n */\nexport function dotProduct(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function dotProduct(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.dotProduct(expr2);\n}\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n * euclideanDistance(\"location\", [37.7749, -122.4194]);\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a field's vector value and a vector expression.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(\"pointA\", field(\"pointB\"));\n * ```\n *\n * @param fieldName - The name of the field containing the first vector.\n * @param vectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  fieldName: string,\n  vectorExpression: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between a vector expression and a double array.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between the 'location' field and a target location\n *\n * euclideanDistance(field(\"location\"), [37.7749, -122.4194]);\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param vector - The other vector (as an array of doubles or VectorValue) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  vector: number[] | VectorValue\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Calculates the Euclidean distance between two vector expressions.\n *\n * @example\n * ```typescript\n * // Calculate the Euclidean distance between two vector fields: 'pointA' and 'pointB'\n * euclideanDistance(field(\"pointA\"), field(\"pointB\"));\n * ```\n *\n * @param vectorExpression - The first vector (represented as an `Expression`) to compare against.\n * @param otherVectorExpression - The other vector (represented as an `Expression`) to compare against.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the Euclidean distance between the two vectors.\n */\nexport function euclideanDistance(\n  vectorExpression: Expression,\n  otherVectorExpression: Expression\n): FunctionExpression;\nexport function euclideanDistance(\n  expr: Expression | string,\n  other: Expression | number[] | VectorValue\n): FunctionExpression {\n  const expr1 = fieldOrExpression(expr);\n  const expr2 = vectorToExpr(other);\n  return expr1.euclideanDistance(expr2);\n}\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(field(\"embedding\"));\n * ```\n *\n * @param vectorExpression - The expression representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(vectorExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that calculates the length of a Firestore Vector represented by a field.\n *\n * @example\n * ```typescript\n * // Get the vector length (dimension) of the field 'embedding'.\n * vectorLength(\"embedding\");\n * ```\n *\n * @param fieldName - The name of the field representing the Firestore Vector.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the length of the array.\n */\nexport function vectorLength(fieldName: string): FunctionExpression;\nexport function vectorLength(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).vectorLength();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(field(\"microseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'microseconds' field as microseconds since epoch.\n * unixMicrosToTimestamp(\"microseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of microseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMicrosToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMicrosToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).unixMicrosToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of microseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to microseconds since epoch.\n * timestampToUnixMicros(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of microseconds since epoch.\n */\nexport function timestampToUnixMicros(fieldName: string): FunctionExpression;\nexport function timestampToUnixMicros(\n  expr: Expression | string\n): FunctionExpression {\n  return fieldOrExpression(expr).timestampToUnixMicros();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(field(\"milliseconds\"));\n * ```\n *\n * @param expr - The expression representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'milliseconds' field as milliseconds since epoch.\n * unixMillisToTimestamp(\"milliseconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of milliseconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixMillisToTimestamp(fieldName: string): FunctionExpression;\nexport function unixMillisToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixMillisToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of milliseconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to milliseconds since epoch.\n * timestampToUnixMillis(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of milliseconds since epoch.\n */\nexport function timestampToUnixMillis(fieldName: string): FunctionExpression;\nexport function timestampToUnixMillis(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixMillis();\n}\n\n/**\n * @beta\n *\n * Creates an expression that interprets an expression as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(field(\"seconds\"));\n * ```\n *\n * @param expr - The expression representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that interprets a field's value as the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC)\n * and returns a timestamp.\n *\n * @example\n * ```typescript\n * // Interpret the 'seconds' field as seconds since epoch.\n * unixSecondsToTimestamp(\"seconds\");\n * ```\n *\n * @param fieldName - The name of the field representing the number of seconds since epoch.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the timestamp.\n */\nexport function unixSecondsToTimestamp(fieldName: string): FunctionExpression;\nexport function unixSecondsToTimestamp(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.unixSecondsToTimestamp();\n}\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp expression to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(field(\"timestamp\"));\n * ```\n *\n * @param expr - The expression representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that converts a timestamp field to the number of seconds since the Unix epoch (1970-01-01 00:00:00 UTC).\n *\n * @example\n * ```typescript\n * // Convert the 'timestamp' field to seconds since epoch.\n * timestampToUnixSeconds(\"timestamp\");\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the number of seconds since epoch.\n */\nexport function timestampToUnixSeconds(fieldName: string): FunctionExpression;\nexport function timestampToUnixSeconds(\n  expr: Expression | string\n): FunctionExpression {\n  const normalizedExpr = fieldOrExpression(expr);\n  return normalizedExpr.timestampToUnixSeconds();\n}\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add some duration determined by field 'unit' and 'amount' to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that adds a specified amount of time to a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Add 1 day to the 'timestamp' field.\n * timestampAdd(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to add (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to add.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampAdd(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampAdd(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampAdd(normalizedUnit, normalizedAmount);\n}\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract some duration determined by field 'unit' and 'amount' from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), field(\"unit\"), field(\"amount\"));\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The expression evaluates to unit of time, must be one of 'microsecond', 'millisecond', 'second', 'minute', 'hour', 'day'.\n * @param amount - The expression evaluates to amount of the unit.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: Expression,\n  amount: Expression\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(field(\"timestamp\"), \"day\", 1);\n * ```\n *\n * @param timestamp - The expression representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  timestamp: Expression,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\n\n/**\n * @beta\n *\n * Creates an expression that subtracts a specified amount of time from a timestamp represented by a field.\n *\n * @example\n * ```typescript\n * // Subtract 1 day from the 'timestamp' field.\n * timestampSubtract(\"timestamp\", \"day\", 1);\n * ```\n *\n * @param fieldName - The name of the field representing the timestamp.\n * @param unit - The unit of time to subtract (e.g., \"day\", \"hour\").\n * @param amount - The amount of time to subtract.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the resulting timestamp.\n */\nexport function timestampSubtract(\n  fieldName: string,\n  unit: 'microsecond' | 'millisecond' | 'second' | 'minute' | 'hour' | 'day',\n  amount: number\n): FunctionExpression;\nexport function timestampSubtract(\n  timestamp: Expression | string,\n  unit:\n    | Expression\n    | 'microsecond'\n    | 'millisecond'\n    | 'second'\n    | 'minute'\n    | 'hour'\n    | 'day',\n  amount: Expression | number\n): FunctionExpression {\n  const normalizedTimestamp = fieldOrExpression(timestamp);\n  const normalizedUnit = valueToDefaultExpr(unit);\n  const normalizedAmount = valueToDefaultExpr(amount);\n  return normalizedTimestamp.timestampSubtract(\n    normalizedUnit,\n    normalizedAmount\n  );\n}\n\n/**\n * @beta\n *\n * Creates an expression that evaluates to the current server timestamp.\n *\n * @example\n * ```typescript\n * // Get the current server timestamp\n * currentTimestamp()\n * ```\n *\n * @returns A new Expression representing the current server timestamp.\n */\nexport function currentTimestamp(): FunctionExpression {\n  return new FunctionExpression('current_timestamp', [], 'currentTimestamp');\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'AND' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 AND the 'city' field is \"London\" AND\n * // the 'status' field is \"active\"\n * const condition = and(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'AND' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'AND' operation.\n */\nexport function and(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'and',\n    [first, second, ...more],\n    'and'\n  ).asBoolean();\n}\n\n/**\n * @beta\n *\n * Creates an expression that performs a logical 'OR' operation on multiple filter conditions.\n *\n * @example\n * ```typescript\n * // Check if the 'age' field is greater than 18 OR the 'city' field is \"London\" OR\n * // the 'status' field is \"active\"\n * const condition = or(greaterThan(\"age\", 18), equal(\"city\", \"London\"), equal(\"status\", \"active\"));\n * ```\n *\n * @param first - The first filter condition.\n * @param second - The second filter condition.\n * @param more - Additional filter conditions to 'OR' together.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logical 'OR' operation.\n */\nexport function or(\n  first: BooleanExpression,\n  second: BooleanExpression,\n  ...more: BooleanExpression[]\n): BooleanExpression {\n  return new FunctionExpression(\n    'or',\n    [first, second, ...more],\n    'xor'\n  ).asBoolean();\n}\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(field(\"base\"), field(\"exponent\"));\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base expression raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(field(\"base\"), 2);\n * ```\n *\n * @param base - The expression to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: Expression, exponent: number): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent expression.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of the 'exponent' field.\n * pow(\"base\", field(\"exponent\"));\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The expression to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the value of the base field raised to the power of the exponent.\n *\n * @example\n * ```typescript\n * // Raise the value of the 'base' field to the power of 2.\n * pow(\"base\", 2);\n * ```\n *\n * @param base - The name of the field to raise to the power of the exponent.\n * @param exponent - The constant value to raise the base to the power of.\n * @returns A new `Expression` representing the power operation.\n */\nexport function pow(base: string, exponent: number): FunctionExpression;\nexport function pow(\n  base: Expression | string,\n  exponent: Expression | number\n): FunctionExpression {\n  return fieldOrExpression(base).pow(exponent as number);\n}\n\n/**\n * @beta\n *\n * Creates an expression that generates a random number between 0.0 and 1.0 but not including 1.0.\n *\n * @example\n * ```typescript\n * // Generate a random number between 0.0 and 1.0.\n * rand();\n * ```\n *\n * @returns A new `Expression` representing the rand operation.\n */\nexport function rand(): FunctionExpression {\n  return new FunctionExpression('rand', [], 'rand');\n}\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(\"price\");\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the nearest whole number.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field.\n * round(field(\"price\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(\"price\", 2);\n * ```\n *\n * @param fieldName - The name of the field to round.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  fieldName: string,\n  decimalPlaces: number | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that rounds a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Round the value of the 'price' field to two decimal places.\n * round(field(\"price\"), constant(2));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be rounded.\n * @param decimalPlaces - A constant or expression specifying the rounding precision in decimal places.\n * @returns A new `Expression` representing the rounded value.\n */\nexport function round(\n  expression: Expression,\n  decimalPlaces: number | Expression\n): FunctionExpression;\nexport function round(\n  expr: Expression | string,\n  decimalPlaces?: number | Expression\n): FunctionExpression {\n  if (decimalPlaces === undefined) {\n    return fieldOrExpression(expr).round();\n  } else {\n    return fieldOrExpression(expr).round(valueToDefaultExpr(decimalPlaces));\n  }\n}\n\n/**\n * @beta\n * Creates an expression that truncates the numeric value of a field to an integer.\n *\n * @example\n * ```typescript\n * // Truncate the value of the 'rating' field\n * trunc(\"rating\");\n * ```\n *\n * @param fieldName - The name of the field containing the number to truncate.\n * @returns A new `Expression` representing the truncated value.\n */\nexport function trunc(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates the numeric value of an expression to an integer.\n *\n * @example\n * ```typescript\n * // Truncate the value of the 'rating' field.\n * trunc(field(\"rating\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be truncated.\n * @returns A new `Expression` representing the truncated value.\n */\nexport function trunc(expression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a numeric expression to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Truncate the value of the 'rating' field to two decimal places.\n * trunc(\"rating\", 2);\n * ```\n *\n * @param fieldName - The name of the field to truncate.\n * @param decimalPlaces - A constant or expression specifying the truncation precision in decimal places.\n * @returns A new `Expression` representing the truncated value.\n */\nexport function trunc(\n  fieldName: string,\n  decimalPlaces: number | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a numeric value to the specified number of decimal places.\n *\n * @example\n * ```typescript\n * // Truncate the value of the 'rating' field to two decimal places.\n * trunc(field(\"rating\"), constant(2));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which will be truncated.\n * @param decimalPlaces - A constant or expression specifying the truncation precision in decimal places.\n * @returns A new `Expression` representing the truncated value.\n */\nexport function trunc(\n  expression: Expression,\n  decimalPlaces: number | Expression\n): FunctionExpression;\nexport function trunc(\n  expr: Expression | string,\n  decimalPlaces?: number | Expression\n): FunctionExpression {\n  if (decimalPlaces === undefined) {\n    return fieldOrExpression(expr).trunc();\n  } else {\n    return fieldOrExpression(expr).trunc(valueToDefaultExpr(decimalPlaces));\n  }\n}\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(\"__name__\");\n * ```\n *\n * @param fieldName - The name of the field to get the collection ID from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that returns the collection ID from a path.\n *\n * @example\n * ```typescript\n * // Get the collection ID from a path.\n * collectionId(field(\"__name__\"));\n * ```\n *\n * @param expression - An expression evaluating to a path, which the collection ID will be extracted from.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the collectionId operation.\n */\nexport function collectionId(expression: Expression): FunctionExpression;\nexport function collectionId(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).collectionId();\n}\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(\"name\");\n *\n * // Get the number of items in the 'cart' array.\n * length(\"cart\");\n * ```\n *\n * @param fieldName - The name of the field to calculate the length of.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that calculates the length of a string, array, map, vector, or bytes.\n *\n * @example\n * ```typescript\n * // Get the length of the 'name' field.\n * length(field(\"name\"));\n *\n * // Get the number of items in the 'cart' array.\n * length(field(\"cart\"));\n * ```\n *\n * @param expression - An expression evaluating to a string, array, map, vector, or bytes, which the length will be calculated for.\n * @returns A new `Expression` representing the length of the string, array, map, vector, or bytes.\n */\nexport function length(expression: Expression): FunctionExpression;\nexport function length(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).length();\n}\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the natural logarithm of.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the natural logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the natural logarithm of the 'value' field.\n * ln(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the natural logarithm will be computed for.\n * @returns A new `Expression` representing the natural logarithm of the numeric value.\n */\nexport function ln(expression: Expression): FunctionExpression;\nexport function ln(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).ln();\n}\n\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(field(\"value\"), 10);\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(expression: Expression, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of an expression to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(field(\"value\"), field(\"base\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the logarithm will be computed for.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(\n  expression: Expression,\n  base: Expression\n): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with base 10.\n * log(\"value\", 10);\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: number): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the logarithm of a field to a given base.\n *\n * @example\n * ```typescript\n * // Compute the logarithm of the 'value' field with the base in the 'base' field.\n * log(\"value\", field(\"base\"));\n * ```\n *\n * @param fieldName - The name of the field to compute the logarithm of.\n * @param base - The base of the logarithm.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the logarithm of the numeric value.\n */\nexport function log(fieldName: string, base: Expression): FunctionExpression;\nexport function log(\n  expr: Expression | string,\n  base: number | Expression\n): FunctionExpression {\n  return new FunctionExpression('log', [\n    fieldOrExpression(expr),\n    valueToDefaultExpr(base)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the square root will be computed for.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(expression: Expression): FunctionExpression;\n/**\n * @beta\n * Creates an expression that computes the square root of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the square root of the 'value' field.\n * sqrt(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the square root of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the square root of the numeric value.\n */\nexport function sqrt(fieldName: string): FunctionExpression;\nexport function sqrt(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).sqrt();\n}\n\n/**\n * @beta\n * Creates an expression that reverses a string.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(field(\"myString\"));\n * ```\n *\n * @param stringExpression - An expression evaluating to a string value, which will be reversed.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(stringExpression: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that reverses a string value in the specified field.\n *\n * @example\n * ```typescript\n * // Reverse the value of the 'myString' field.\n * strReverse(\"myString\");\n * ```\n *\n * @param field - The name of the field representing the string to reverse.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the reversed string.\n */\nexport function stringReverse(field: string): FunctionExpression;\nexport function stringReverse(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).stringReverse();\n}\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate the 'firstName' and 'lastName' fields with a space in between.\n * concat(field(\"firstName\"), \" \", field(\"lastName\"))\n * ```\n *\n * @param first - The first expressions to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literals or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  first: Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that concatenates strings, arrays, or blobs. Types cannot be mixed.\n *\n * @example\n * ```typescript\n * // Concatenate a field with a literal string.\n * concat(field(\"firstName\"), \"Doe\")\n * ```\n *\n * @param fieldName - The name of a field to concatenate.\n * @param second - The second literal or expression to concatenate.\n * @param others - Additional literal or expressions to concatenate.\n * @returns A new `Expression` representing the concatenation.\n */\nexport function concat(\n  fieldName: string,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression;\n\nexport function concat(\n  fieldNameOrExpression: string | Expression,\n  second: Expression | unknown,\n  ...others: Array<Expression | unknown>\n): FunctionExpression {\n  return new FunctionExpression('concat', [\n    fieldOrExpression(fieldNameOrExpression),\n    valueToDefaultExpr(second),\n    ...others.map(valueToDefaultExpr)\n  ]);\n}\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param expr - The expression to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(expr: Expression): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the absolute value of a numeric value.\n *\n * @param fieldName - The field to compute the absolute value of.\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the absolute value of the numeric value.\n */\nexport function abs(fieldName: string): FunctionExpression;\nexport function abs(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).abs();\n}\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifExpr` is absent, else return\n * the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), constant(\"default_value\"))\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if [ifExpr] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifExpr` is absent, else\n * return the result of the `ifExpr` argument evaluation.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(field(\"optional_field\"), \"default_value\")\n * ```\n *\n * @param ifExpr - The expression to check for absence.\n * @param elseValue - The value that will be returned if `ifExpr` evaluates to an absent value.\n * @returns A new [Expression] representing the ifAbsent operation.\n */\nexport function ifAbsent(ifExpr: Expression, elseValue: unknown): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseExpr` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns the value of\n * // 'default_field' if 'optional_field' is absent.\n * ifAbsent(\"optional_field\", field(\"default_field\"))\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseExpr - The expression that will be evaluated and returned if `ifFieldName` is\n * absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(ifFieldName: string, elseExpr: Expression): Expression;\n\n/**\n * @beta\n * Creates an expression that returns the `elseValue` argument if `ifFieldName` is absent, else\n * return the value of the field.\n *\n * @example\n * ```typescript\n * // Returns the value of the optional field 'optional_field', or returns 'default_value'\n * // if the field is absent.\n * ifAbsent(\"optional_field\", \"default_value\")\n * ```\n *\n * @param ifFieldName - The field to check for absence.\n * @param elseValue - The value that will be returned if [ifFieldName] is absent.\n * @returns A new Expression representing the ifAbsent operation.\n */\nexport function ifAbsent(\n  ifFieldName: string | Expression,\n  elseValue: Expression | unknown\n): Expression;\nexport function ifAbsent(\n  fieldNameOrExpression: string | Expression,\n  elseValue: Expression | unknown\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).ifAbsent(\n    valueToDefaultExpr(elseValue)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(\"tags\", \", \")\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(arrayFieldName: string, delimiter: string): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join an array of string using the delimiter from the 'separator' field.\n * join(array(['foo', 'bar']), field(\"separator\"))\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiterExpression: Expression\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with a comma and space.\n * join(field(\"tags\"), \", \")\n * ```\n *\n * @param arrayExpression - An expression that evaluates to an array.\n * @param delimiter - The string to use as a delimiter.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayExpression: Expression,\n  delimiter: string\n): Expression;\n\n/**\n * @beta\n * Creates an expression that joins the elements of an array into a string.\n *\n * @example\n * ```typescript\n * // Join the elements of the 'tags' field with the delimiter from the 'separator' field.\n * join('tags', field(\"separator\"))\n * ```\n *\n * @param arrayFieldName - The name of the field containing the array.\n * @param delimiterExpression - The expression that evaluates to the delimiter string.\n * @returns A new Expression representing the join operation.\n */\nexport function join(\n  arrayFieldName: string,\n  delimiterExpression: Expression\n): Expression;\nexport function join(\n  fieldNameOrExpression: string | Expression,\n  delimiterValueOrExpression: Expression | string\n): Expression {\n  return fieldOrExpression(fieldNameOrExpression).join(\n    valueToDefaultExpr(delimiterValueOrExpression)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(\"value\");\n * ```\n *\n * @param fieldName - The name of the field to compute the base-10 logarithm of.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the base-10 logarithm of a numeric value.\n *\n * @example\n * ```typescript\n * // Compute the base-10 logarithm of the 'value' field.\n * log10(field(\"value\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric value, which the base-10 logarithm will be computed for.\n * @returns A new `Expression` representing the base-10 logarithm of the numeric value.\n */\nexport function log10(expression: Expression): FunctionExpression;\nexport function log10(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).log10();\n}\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(\"scores\");\n * ```\n *\n * @param fieldName - The name of the field to compute the sum of.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(fieldName: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that computes the sum of the elements in an array.\n *\n * @example\n * ```typescript\n * // Compute the sum of the elements in the 'scores' field.\n * arraySum(field(\"scores\"));\n * ```\n *\n * @param expression - An expression evaluating to a numeric array, which the sum will be computed for.\n * @returns A new `Expression` representing the sum of the elements in the array.\n */\nexport function arraySum(expression: Expression): FunctionExpression;\nexport function arraySum(expr: Expression | string): FunctionExpression {\n  return fieldOrExpression(expr).arraySum();\n}\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split('scoresCsv', ',')\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(fieldName: string, delimiter: string): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits the value of a field on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split('scores', conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param fieldName - Split the value in this field.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  fieldName: string,\n  delimiter: Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scoresCsv' field on delimiter ','\n * split(field('scoresCsv'), ',')\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: string\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that splits a string into an array of substrings based on the provided delimiter.\n *\n * @example\n * ```typescript\n * // Split the 'scores' field on delimiter ',' or ':' depending on the stored format\n * split(field('scores'), conditional(field('format').equal('csv'), constant(','), constant(':'))\n * ```\n *\n * @param expression - Split the result of this expression.\n * @param delimiter - Split on this delimiter returned by evaluating this expression.\n *\n * @returns A new {@link @firebase/firestore/pipelines#Expression} representing the split function.\n */\nexport function split(\n  expression: Expression,\n  delimiter: Expression\n): FunctionExpression;\nexport function split(\n  fieldNameOrExpression: string | Expression,\n  delimiter: string | Expression\n): FunctionExpression {\n  return fieldOrExpression(fieldNameOrExpression).split(\n    valueToDefaultExpr(delimiter)\n  );\n}\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param fieldName - Truncate the timestamp value contained in this field.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  fieldName: string,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the beginning of the day.\n * field('createdAt').timestampTruncate('day')\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: TimeGranularity,\n  timezone?: string | Expression\n): FunctionExpression;\n\n/**\n * @beta\n * Creates an expression that truncates a timestamp to a specified granularity.\n *\n * @example\n * ```typescript\n * // Truncate the 'createdAt' timestamp to the granularity specified in the field 'granularity'.\n * field('createdAt').timestampTruncate(field('granularity'))\n * ```\n *\n * @param timestampExpression - Truncate the timestamp value that is returned by this expression.\n * @param granularity - The granularity to truncate to.\n * @param timezone - The timezone to use for truncation. Valid values are from\n * the TZ database (e.g., \"America/Los_Angeles\") or in the format \"Etc/GMT-1\".\n * @returns A new `Expression` representing the truncated timestamp.\n */\nexport function timestampTruncate(\n  timestampExpression: Expression,\n  granularity: Expression,\n  timezone?: string | Expression\n): FunctionExpression;\nexport function timestampTruncate(\n  fieldNameOrExpression: string | Expression,\n  granularity: TimeGranularity | Expression,\n  timezone?: string | Expression\n): FunctionExpression {\n  const internalGranularity = isString(granularity)\n    ? valueToDefaultExpr(granularity.toLowerCase())\n    : granularity;\n  return fieldOrExpression(fieldNameOrExpression).timestampTruncate(\n    internalGranularity,\n    timezone\n  );\n}\n\n// TODO(new-expression): Add new top-level expression function definitions above this line\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in ascending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in ascending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(ascending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create an ascending ordering for.\n * @returns A new `Ordering` for ascending sorting.\n */\nexport function ascending(fieldName: string): Ordering;\nexport function ascending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'ascending', 'ascending');\n}\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on an expression.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in lowercase in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(field(\"name\").toLower()));\n * ```\n *\n * @param expr - The expression to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(expr: Expression): Ordering;\n\n/**\n * @beta\n *\n * Creates an {@link @firebase/firestore/pipelines#Ordering} that sorts documents in descending order based on a field.\n *\n * @example\n * ```typescript\n * // Sort documents by the 'name' field in descending order\n * firestore.pipeline().collection(\"users\")\n *   .sort(descending(\"name\"));\n * ```\n *\n * @param fieldName - The field to create a descending ordering for.\n * @returns A new `Ordering` for descending sorting.\n */\nexport function descending(fieldName: string): Ordering;\nexport function descending(field: Expression | string): Ordering {\n  return new Ordering(fieldOrExpression(field), 'descending', 'descending');\n}\n\n/**\n * @beta\n *\n * Represents an ordering criterion for sorting documents in a Firestore pipeline.\n *\n * You create `Ordering` instances using the `ascending` and `descending` helper functions.\n */\nexport class Ordering implements ProtoValueSerializable, UserData {\n  constructor(\n    public readonly expr: Expression,\n    public readonly direction: 'ascending' | 'descending',\n    readonly _methodName: string | undefined\n  ) {}\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoValue {\n    return {\n      mapValue: {\n        fields: {\n          direction: toStringValue(this.direction),\n          expression: this.expr._toProto(serializer)\n        }\n      }\n    };\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _readUserData(context: ParseContext): void {\n    this.expr._readUserData(context);\n  }\n\n  _protoValueType: 'ProtoValue' = 'ProtoValue';\n}\n\nexport function isSelectable(val: unknown): val is Selectable {\n  const candidate = val as Selectable;\n  return (\n    candidate.selectable && isString(candidate.alias) && isExpr(candidate.expr)\n  );\n}\n\nexport function isOrdering(val: unknown): val is Ordering {\n  const candidate = val as Ordering;\n  return (\n    isExpr(candidate.expr) &&\n    (candidate.direction === 'ascending' ||\n      candidate.direction === 'descending')\n  );\n}\n\nexport function isAliasedAggregate(val: unknown): val is AliasedAggregate {\n  const candidate = val as AliasedAggregate;\n  return (\n    isString(candidate.alias) &&\n    candidate.aggregate instanceof AggregateFunction\n  );\n}\n\nexport function isExpr(val: unknown): val is Expression {\n  return val instanceof Expression;\n}\n\nexport function isBooleanExpr(val: unknown): val is BooleanExpression {\n  return val instanceof BooleanExpression;\n}\n\nexport function isField(val: unknown): val is Field {\n  return val instanceof Field;\n}\n\nexport function toField(value: string | Field): Field {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return value as Field;\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Firestore } from '../lite-api/database';\nimport {\n  Constant,\n  BooleanExpression,\n  and,\n  or,\n  Ordering,\n  lessThan,\n  greaterThan,\n  field\n} from '../lite-api/expressions';\nimport { Pipeline } from '../lite-api/pipeline';\nimport { doc } from '../lite-api/reference';\nimport { fail } from '../util/assert';\n\nimport { Bound } from './bound';\nimport {\n  CompositeFilter as CompositeFilterInternal,\n  CompositeOperator,\n  FieldFilter as FieldFilterInternal,\n  Filter as FilterInternal,\n  Operator\n} from './filter';\nimport { Direction } from './order_by';\nimport {\n  isCollectionGroupQuery,\n  isDocumentQuery,\n  LimitType,\n  Query,\n  queryNormalizedOrderBy\n} from './query';\n\n/* eslint @typescript-eslint/no-explicit-any: 0 */\n\nexport function toPipelineBooleanExpr(f: FilterInternal): BooleanExpression {\n  if (f instanceof FieldFilterInternal) {\n    const fieldValue = field(f.field.toString());\n    // Comparison filters\n    const value = f.value;\n    switch (f.op) {\n      case Operator.LESS_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThan(Constant._fromProto(value))\n        );\n      case Operator.LESS_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.lessThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThan(Constant._fromProto(value))\n        );\n      case Operator.GREATER_THAN_OR_EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.greaterThanOrEqual(Constant._fromProto(value))\n        );\n      case Operator.EQUAL:\n        return and(\n          fieldValue.exists(),\n          fieldValue.equal(Constant._fromProto(value))\n        );\n      case Operator.NOT_EQUAL:\n        return fieldValue.notEqual(Constant._fromProto(value));\n      case Operator.ARRAY_CONTAINS:\n        return and(\n          fieldValue.exists(),\n          fieldValue.arrayContains(Constant._fromProto(value))\n        );\n      case Operator.IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return and(fieldValue.exists(), fieldValue.equalAny([]));\n        } else if (values.length === 1) {\n          return and(fieldValue.exists(), fieldValue.equal(values[0]));\n        } else {\n          return and(fieldValue.exists(), fieldValue.equalAny(values));\n        }\n      }\n      case Operator.ARRAY_CONTAINS_ANY: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        return and(fieldValue.exists(), fieldValue.arrayContainsAny(values!));\n      }\n      case Operator.NOT_IN: {\n        const values = value?.arrayValue?.values?.map((val: any) =>\n          Constant._fromProto(val)\n        );\n        if (!values) {\n          return fieldValue.notEqualAny([]);\n        } else if (values.length === 1) {\n          return fieldValue.notEqual(values[0]);\n        } else {\n          return fieldValue.notEqualAny(values);\n        }\n      }\n      default:\n        fail(0x9047, 'Unexpected operator');\n    }\n  } else if (f instanceof CompositeFilterInternal) {\n    switch (f.op) {\n      case CompositeOperator.AND: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return and(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      case CompositeOperator.OR: {\n        const conditions = f.getFilters().map(f => toPipelineBooleanExpr(f));\n        return or(conditions[0], conditions[1], ...conditions.slice(2));\n      }\n      default:\n        fail(0x89ea, 'Unexpected operator');\n    }\n  }\n\n  throw new Error(`Failed to convert filter to pipeline conditions: ${f}`);\n}\n\nfunction reverseOrderings(orderings: Ordering[]): Ordering[] {\n  return orderings.map(\n    o =>\n      new Ordering(\n        o.expr,\n        o.direction === 'ascending' ? 'descending' : 'ascending',\n        undefined\n      )\n  );\n}\n\nexport function toPipeline(query: Query, db: Firestore): Pipeline {\n  let pipeline: Pipeline;\n  if (isCollectionGroupQuery(query)) {\n    pipeline = db.pipeline().collectionGroup(query.collectionGroup!);\n  } else if (isDocumentQuery(query)) {\n    pipeline = db.pipeline().documents([doc(db, query.path.canonicalString())]);\n  } else {\n    pipeline = db.pipeline().collection(query.path.canonicalString());\n  }\n\n  // filters\n  for (const filter of query.filters) {\n    pipeline = pipeline.where(toPipelineBooleanExpr(filter));\n  }\n\n  // orders\n  const orders = queryNormalizedOrderBy(query);\n  const existsConditions = query.explicitOrderBy.map(order =>\n    field(order.field.canonicalString()).exists()\n  );\n  if (existsConditions.length > 0) {\n    const condition =\n      existsConditions.length === 1\n        ? existsConditions[0]\n        : and(\n            existsConditions[0],\n            existsConditions[1],\n            ...existsConditions.slice(2)\n          );\n    pipeline = pipeline.where(condition);\n  }\n\n  const orderings = orders.map(order =>\n    order.dir === Direction.ASCENDING\n      ? field(order.field.canonicalString()).ascending()\n      : field(order.field.canonicalString()).descending()\n  );\n\n  if (orderings.length > 0) {\n    if (query.limitType === LimitType.Last) {\n      const actualOrderings = reverseOrderings(orderings);\n      pipeline = pipeline.sort(actualOrderings[0], ...actualOrderings.slice(1));\n      // cursors\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      pipeline = pipeline.limit(query.limit!);\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n    } else {\n      pipeline = pipeline.sort(orderings[0], ...orderings.slice(1));\n      if (query.startAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.startAt, orderings, 'after')\n        );\n      }\n      if (query.endAt !== null) {\n        pipeline = pipeline.where(\n          whereConditionsFromCursor(query.endAt, orderings, 'before')\n        );\n      }\n\n      if (query.limit !== null) {\n        pipeline = pipeline.limit(query.limit);\n      }\n    }\n  }\n\n  return pipeline;\n}\n\nfunction whereConditionsFromCursor(\n  bound: Bound,\n  orderings: Ordering[],\n  position: 'before' | 'after'\n): BooleanExpression {\n  // The filterFunc is either greater than or less than\n  const filterFunc = position === 'before' ? lessThan : greaterThan;\n  const cursors = bound.position.map(value => Constant._fromProto(value));\n  const size = cursors.length;\n\n  let field = orderings[size - 1].expr;\n  let value = cursors[size - 1];\n\n  // Add condition for last bound\n  let condition: BooleanExpression = filterFunc(field, value);\n  if (bound.inclusive) {\n    // When the cursor bound is inclusive, then the last bound\n    // can be equal to the value, otherwise it's not equal\n    condition = or(condition, field.equal(value));\n  }\n\n  // Iterate backwards over the remaining bounds, adding\n  // a condition for each one\n  for (let i = size - 2; i >= 0; i--) {\n    field = orderings[i].expr;\n    value = cursors[i];\n\n    // For each field in the orderings, the condition is either\n    // a) lt|gt the cursor value,\n    // b) or equal the cursor value and lt|gt the cursor values for other fields\n    condition = or(\n      filterFunc(field, value),\n      and(field.equal(value), condition)\n    );\n  }\n\n  return condition;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ParseContext } from '../api/parse_context';\nimport { OptionsUtil } from '../core/options_util';\nimport {\n  ApiClientObjectMap,\n  firestoreV1ApiClientInterfaces,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { toNumber } from '../remote/number_serializer';\nimport {\n  JsonProtoSerializer,\n  ProtoSerializable,\n  toMapValue,\n  toPipelineValue,\n  toStringValue\n} from '../remote/serializer';\nimport { hardAssert } from '../util/assert';\n\nimport {\n  AggregateFunction,\n  BooleanExpression,\n  Expression,\n  Field,\n  field,\n  Ordering\n} from './expressions';\nimport { Pipeline } from './pipeline';\nimport { StageOptions } from './stage_options';\nimport { isUserData, UserData } from './user_data_reader';\n\n/**\n * @beta\n */\nexport abstract class Stage implements ProtoSerializable<ProtoStage>, UserData {\n  /**\n   * Store optionsProto parsed by _readUserData.\n   * @private\n   * @internal\n   * @protected\n   */\n  protected optionsProto:\n    | ApiClientObjectMap<firestoreV1ApiClientInterfaces.Value>\n    | undefined = undefined;\n  protected knownOptions: Record<string, unknown>;\n  protected rawOptions?: Record<string, unknown>;\n\n  constructor(options: StageOptions) {\n    ({ rawOptions: this.rawOptions, ...this.knownOptions } = options);\n  }\n\n  _readUserData(context: ParseContext): void {\n    this.optionsProto = this._optionsUtil.getOptionsProto(\n      context,\n      this.knownOptions,\n      this.rawOptions\n    );\n  }\n\n  _toProto(_: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this._name,\n      options: this.optionsProto\n    };\n  }\n\n  abstract get _optionsUtil(): OptionsUtil;\n  abstract get _name(): string;\n}\n\n/**\n * @beta\n */\nexport class AddFields extends Stage {\n  get _name(): string {\n    return 'add_fields';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.fields)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RemoveFields extends Stage {\n  get _name(): string {\n    return 'remove_fields';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private fields: Field[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.fields.map(f => f._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.fields, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Aggregate extends Stage {\n  get _name(): string {\n    return 'aggregate';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private groups: Map<string, Expression>,\n    private accumulators: Map<string, AggregateFunction>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        toMapValue(serializer, this.accumulators),\n        toMapValue(serializer, this.groups)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n    readUserDataHelper(this.accumulators, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Distinct extends Stage {\n  get _name(): string {\n    return 'distinct';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private groups: Map<string, Expression>, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.groups)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.groups, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionSource extends Stage {\n  get _name(): string {\n    return 'collection';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  private formattedCollectionPath: string;\n\n  constructor(collection: string, options: StageOptions) {\n    super(options);\n\n    // prepend slash to collection string\n    this.formattedCollectionPath = collection.startsWith('/')\n      ? collection\n      : '/' + collection;\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: this.formattedCollectionPath }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class CollectionGroupSource extends Stage {\n  get _name(): string {\n    return 'collection_group';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      forceIndex: {\n        serverName: 'force_index'\n      }\n    });\n  }\n\n  constructor(private collectionId: string, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [{ referenceValue: '' }, { stringValue: this.collectionId }]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DatabaseSource extends Stage {\n  get _name(): string {\n    return 'database';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer)\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class DocumentsSource extends Stage {\n  get _name(): string {\n    return 'documents';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  private formattedPaths: string[];\n\n  constructor(docPaths: string[], options: StageOptions) {\n    super(options);\n    this.formattedPaths = docPaths.map(path =>\n      path.startsWith('/') ? path : '/' + path\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.formattedPaths.map(p => {\n        return { referenceValue: p };\n      })\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Where extends Stage {\n  get _name(): string {\n    return 'where';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private condition: BooleanExpression, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.condition._toProto(serializer)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.condition, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class FindNearest extends Stage {\n  get _name(): string {\n    return 'find_nearest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      limit: {\n        serverName: 'limit'\n      },\n      distanceField: {\n        serverName: 'distance_field'\n      }\n    });\n  }\n\n  constructor(\n    private vectorValue: Expression,\n    private field: Field,\n    private distanceMeasure: 'euclidean' | 'cosine' | 'dot_product',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @private\n   * @internal\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.field._toProto(serializer),\n        this.vectorValue._toProto(serializer),\n        toStringValue(this.distanceMeasure)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.vectorValue, context);\n    readUserDataHelper(this.field, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Limit extends Stage {\n  get _name(): string {\n    return 'limit';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private limit: number, options: StageOptions) {\n    hardAssert(\n      !isNaN(limit) && limit !== Infinity && limit !== -Infinity,\n      0x882c,\n      'Invalid limit value'\n    );\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.limit)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Offset extends Stage {\n  get _name(): string {\n    return 'offset';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private offset: number, options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.offset)]\n    };\n  }\n}\n\n/**\n * @beta\n */\nexport class Select extends Stage {\n  get _name(): string {\n    return 'select';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private selections: Map<string, Expression>,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toMapValue(serializer, this.selections)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.selections, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sort extends Stage {\n  get _name(): string {\n    return 'sort';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private orderings: Ordering[], options: StageOptions) {\n    super(options);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: this.orderings.map(o => o._toProto(serializer))\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.orderings, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Sample extends Stage {\n  get _name(): string {\n    return 'sample';\n  }\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(\n    private rate: number,\n    private mode: 'percent' | 'documents',\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toNumber(serializer, this.rate)!, toStringValue(this.mode)!]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Union extends Stage {\n  get _name(): string {\n    return 'union';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private other: Pipeline, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [toPipelineValue(this.other._toProto(serializer))]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Unnest extends Stage {\n  get _name(): string {\n    return 'unnest';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({\n      indexField: {\n        serverName: 'index_field'\n      }\n    });\n  }\n\n  constructor(\n    private alias: string,\n    private expr: Expression,\n    options: StageOptions\n  ) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [\n        this.expr._toProto(serializer),\n        field(this.alias)._toProto(serializer)\n      ]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.expr, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class Replace extends Stage {\n  static readonly MODE = 'full_replace';\n\n  get _name(): string {\n    return 'replace_with';\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n\n  constructor(private map: Expression, options: StageOptions) {\n    super(options);\n  }\n\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      ...super._toProto(serializer),\n      args: [this.map._toProto(serializer), toStringValue(Replace.MODE)]\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.map, context);\n  }\n}\n\n/**\n * @beta\n */\nexport class RawStage extends Stage {\n  /**\n   * @private\n   * @internal\n   */\n  constructor(\n    private name: string,\n    private params: Array<AggregateFunction | Expression>,\n    rawOptions: Record<string, unknown>\n  ) {\n    super({ rawOptions });\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(serializer: JsonProtoSerializer): ProtoStage {\n    return {\n      name: this.name,\n      args: this.params.map(o => o._toProto(serializer)),\n      options: this.optionsProto\n    };\n  }\n\n  _readUserData(context: ParseContext): void {\n    super._readUserData(context);\n    readUserDataHelper(this.params, context);\n  }\n\n  get _name(): string {\n    return this.name;\n  }\n\n  get _optionsUtil(): OptionsUtil {\n    return new OptionsUtil({});\n  }\n}\n\n/**\n * Helper to read user data across a number of different formats.\n * @param name - Name of the calling function. Used for error messages when invalid user data is encountered.\n * @param expressionMap\n * @returns the expressionMap argument.\n * @private\n */\nfunction readUserDataHelper<\n  T extends Map<string, UserData> | UserData[] | UserData\n>(expressionMap: T, context: ParseContext): T {\n  if (isUserData(expressionMap)) {\n    expressionMap._readUserData(context);\n  } else if (Array.isArray(expressionMap)) {\n    expressionMap.forEach(readableData => readableData._readUserData(context));\n  } else {\n    expressionMap.forEach(expr => expr._readUserData(context));\n  }\n  return expressionMap;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DatabaseId } from '../core/database_info';\nimport { toPipeline } from '../core/pipeline-util';\nimport { Code, FirestoreError } from '../util/error';\nimport { isString } from '../util/types';\n\nimport { Pipeline } from './pipeline';\nimport {\n  CollectionReference,\n  DocumentReference,\n  isCollectionReference,\n  Query\n} from './reference';\nimport {\n  CollectionGroupSource,\n  CollectionSource,\n  DatabaseSource,\n  DocumentsSource,\n  Stage\n} from './stage';\nimport {\n  CollectionGroupStageOptions,\n  CollectionStageOptions,\n  DatabaseStageOptions,\n  DocumentsStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\n\n/**\n * @beta\n * Provides the entry point for defining the data source of a Firestore {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * Use the methods of this class (e.g., {@link @firebase/firestore/pipelines#PipelineSource.(collection:1)}, {@link @firebase/firestore/pipelines#PipelineSource.(collectionGroup:1)},\n * {@link @firebase/firestore/pipelines#PipelineSource.(database:1)}, or {@link @firebase/firestore/pipelines#PipelineSource.(documents:1)}) to specify the initial data\n * for your pipeline, such as a collection, a collection group, the entire database, or a set of specific documents.\n */\nexport class PipelineSource<PipelineType> {\n  /**\n   * @internal\n   * @private\n   * @param databaseId\n   * @param userDataReader\n   * @param _createPipeline\n   */\n  constructor(\n    private databaseId: DatabaseId,\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _createPipeline: (stages: Stage[]) => PipelineType\n  ) {}\n\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param collection - Name or reference to the collection that will be used as the Pipeline source.\n   */\n  collection(collection: string | CollectionReference): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire collection. The collection can be nested.\n   * @param options - Options defining how this CollectionStage is evaluated.\n   */\n  collection(options: CollectionStageOptions): PipelineType;\n  collection(\n    collectionOrOptions: string | CollectionReference | CollectionStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? {}\n        : collectionOrOptions;\n    const collectionRefOrString =\n      isString(collectionOrOptions) ||\n      isCollectionReference(collectionOrOptions)\n        ? collectionOrOptions\n        : collectionOrOptions.collection;\n\n    // Validate that a user provided reference is for the same Firestore DB\n    if (isCollectionReference(collectionRefOrString)) {\n      this._validateReference(collectionRefOrString);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedCollection = isString(collectionRefOrString)\n      ? (collectionRefOrString as string)\n      : collectionRefOrString.path;\n\n    // Create stage object\n    const stage = new CollectionSource(normalizedCollection, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collection'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param collectionId - ID of the collection group to use as the Pipeline source.\n   */\n  collectionGroup(collectionId: string): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from a collection ID regardless of the parent.\n   * @param options - Options defining how this CollectionGroupStage is evaluated.\n   */\n  collectionGroup(options: CollectionGroupStageOptions): PipelineType;\n  collectionGroup(\n    collectionIdOrOptions: string | CollectionGroupStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let collectionId: string;\n    let options: {};\n    if (isString(collectionIdOrOptions)) {\n      collectionId = collectionIdOrOptions;\n      options = {};\n    } else {\n      ({ collectionId, ...options } = collectionIdOrOptions);\n    }\n\n    // Create stage object\n    const stage = new CollectionGroupSource(collectionId, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'collectionGroup'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   */\n  database(): PipelineType;\n  /**\n   * @beta\n   * Returns all documents from the entire database.\n   * @param options - Options defining how a DatabaseStage is evaluated.\n   */\n  database(options: DatabaseStageOptions): PipelineType;\n  database(options?: DatabaseStageOptions): PipelineType {\n    // Process argument union(s) from method overloads\n    options = options ?? {};\n\n    // Create stage object\n    const stage = new DatabaseSource(options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'database'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param docs - An array of paths and DocumentReferences specifying the individual documents that will be the source of this pipeline.\n   * The converters for these DocumentReferences will be ignored and not have an effect on this pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(docs: Array<string | DocumentReference>): PipelineType;\n\n  /**\n   * @beta\n   * Set the pipeline's source to the documents specified by the given paths and DocumentReferences.\n   *\n   * @param options - Options defining how this DocumentsStage is evaluated.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  documents(options: DocumentsStageOptions): PipelineType;\n  documents(\n    docsOrOptions: Array<string | DocumentReference> | DocumentsStageOptions\n  ): PipelineType {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let docs: Array<string | DocumentReference>;\n    if (Array.isArray(docsOrOptions)) {\n      docs = docsOrOptions;\n      options = {};\n    } else {\n      ({ docs, ...options } = docsOrOptions);\n    }\n\n    // Validate that all user provided references are for the same Firestore DB\n    docs\n      .filter(v => v instanceof DocumentReference)\n      .forEach(dr => this._validateReference(dr as DocumentReference));\n\n    // Convert user land convenience types to internal types\n    const normalizedDocs: string[] = docs.map(doc =>\n      isString(doc) ? doc : doc.path\n    );\n\n    // Create stage object\n    const stage = new DocumentsSource(normalizedDocs, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'documents'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._createPipeline([stage]);\n  }\n\n  /**\n   * @beta\n   * Convert the given Query into an equivalent Pipeline.\n   *\n   * @param query - A Query to be converted into a Pipeline.\n   *\n   * @throws `FirestoreError` Thrown if any of the provided DocumentReferences target a different project or database than the pipeline.\n   */\n  createFrom(query: Query): Pipeline {\n    return toPipeline(query._query, query.firestore);\n  }\n\n  _validateReference(reference: CollectionReference | DocumentReference): void {\n    const refDbId = reference.firestore._databaseId;\n    if (!refDbId.isEqual(this.databaseId)) {\n      throw new FirestoreError(\n        Code.INVALID_ARGUMENT,\n        `Invalid ${\n          reference instanceof CollectionReference\n            ? 'CollectionReference'\n            : 'DocumentReference'\n        }. ` +\n          `The project ID (\"${refDbId.projectId}\") or the database (\"${refDbId.database}\") does not match ` +\n          `the project ID (\"${this.databaseId.projectId}\") and database (\"${this.databaseId.database}\") of the target database of this Pipeline.`\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ObjectValue } from '../model/object_value';\nimport { firestoreV1ApiClientInterfaces } from '../protos/firestore_proto_api';\nimport { isOptionalEqual } from '../util/misc';\n\nimport { Field, isField } from './expressions';\nimport { FieldPath } from './field_path';\nimport { Pipeline } from './pipeline';\nimport { DocumentData, DocumentReference, refEqual } from './reference';\nimport { Timestamp } from './timestamp';\nimport { fieldPathFromArgument } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n * Represents the results of a Firestore pipeline execution.\n *\n * A `PipelineSnapshot` contains zero or more {@link @firebase/firestore/pipelines#PipelineResult} objects\n * representing the documents returned by a pipeline query. It provides methods\n * to iterate over the documents and access metadata about the query results.\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await firestore\n *   .pipeline()\n *   .collection('myCollection')\n *   .where(field('value').greaterThan(10))\n *   .execute();\n *\n * snapshot.results.forEach(doc => {\n *   console.log(doc.id, '=>', doc.data());\n * });\n * ```\n */\nexport class PipelineSnapshot {\n  private readonly _pipeline: Pipeline;\n  private readonly _executionTime: Timestamp | undefined;\n  private readonly _results: PipelineResult[];\n  constructor(\n    pipeline: Pipeline,\n    results: PipelineResult[],\n    executionTime?: Timestamp\n  ) {\n    this._pipeline = pipeline;\n    this._executionTime = executionTime;\n    this._results = results;\n  }\n\n  /**\n   * @beta An array of all the results in the `PipelineSnapshot`.\n   */\n  get results(): PipelineResult[] {\n    return this._results;\n  }\n\n  /**\n   * @beta\n   * The time at which the pipeline producing this result is executed.\n   *\n   * @readonly\n   *\n   */\n  get executionTime(): Timestamp {\n    if (this._executionTime === undefined) {\n      throw new Error(\n        \"'executionTime' is expected to exist, but it is undefined\"\n      );\n    }\n    return this._executionTime;\n  }\n}\n\n/**\n * @beta\n *\n * A PipelineResult contains data read from a Firestore Pipeline. The data can be extracted with the\n * {@link @firebase/firestore/pipelines#PipelineResult.data} or {@link @firebase/firestore/pipelines#PipelineResult.(get:1)} methods.\n *\n * <p>If the PipelineResult represents a non-document result, `ref` will return a undefined\n * value.\n */\nexport class PipelineResult<AppModelType = DocumentData> {\n  private readonly _userDataWriter: AbstractUserDataWriter;\n\n  private readonly _createTime: Timestamp | undefined;\n  private readonly _updateTime: Timestamp | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _ref: DocumentReference | undefined;\n\n  /**\n   * @internal\n   * @private\n   */\n  readonly _fields: ObjectValue;\n\n  /**\n   * @private\n   * @internal\n   *\n   * @param userDataWriter - The serializer used to encode/decode protobuf.\n   * @param ref - The reference to the document.\n   * @param fields - The fields of the Firestore `Document` Protobuf backing\n   * this document.\n   * @param createTime - The time when the document was created if the result is a document, undefined otherwise.\n   * @param updateTime - The time when the document was last updated if the result is a document, undefined otherwise.\n   */\n  constructor(\n    userDataWriter: AbstractUserDataWriter,\n    fields: ObjectValue,\n    ref?: DocumentReference,\n    createTime?: Timestamp,\n    updateTime?: Timestamp\n  ) {\n    this._ref = ref;\n    this._userDataWriter = userDataWriter;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n    this._fields = fields;\n  }\n\n  /**\n   * @beta\n   * The reference of the document, if it is a document; otherwise `undefined`.\n   */\n  get ref(): DocumentReference | undefined {\n    return this._ref;\n  }\n\n  /**\n   * @beta\n   * The ID of the document for which this PipelineResult contains data, if it is a document; otherwise `undefined`.\n   *\n   * @readonly\n   *\n   */\n  get id(): string | undefined {\n    return this._ref?.id;\n  }\n\n  /**\n   * @beta\n   * The time the document was created. Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get createTime(): Timestamp | undefined {\n    return this._createTime;\n  }\n\n  /**\n   * @beta\n   * The time the document was last updated (at the time the snapshot was\n   * generated). Undefined if this result is not a document.\n   *\n   * @readonly\n   */\n  get updateTime(): Timestamp | undefined {\n    return this._updateTime;\n  }\n\n  /**\n   * @beta\n   * Retrieves all fields in the result as an object.\n   *\n   * @returns An object containing all fields in the document or\n   * 'undefined' if the document doesn't exist.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let data = results[0].data();\n   *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n   * });\n   * ```\n   */\n  data(): AppModelType {\n    return this._userDataWriter.convertValue(\n      this._fields.value\n    ) as AppModelType;\n  }\n\n  /**\n   * @internal\n   * @private\n   *\n   * Retrieves all fields in the result as a proto value.\n   *\n   * @returns An `Object` containing all fields in the result.\n   */\n  _fieldsProto(): { [key: string]: firestoreV1ApiClientInterfaces.Value } {\n    // Return a cloned value to prevent manipulation of the Snapshot's data\n    return this._fields.clone().value.mapValue.fields!;\n  }\n\n  /**\n   * @beta\n   * Retrieves the field specified by `field`.\n   *\n   * @param field - The field path\n   * (e.g. 'foo' or 'foo.bar') to a specific field.\n   * @returns The data at the specified field location or `undefined` if no\n   * such field exists.\n   *\n   * @example\n   * ```\n   * let p = firestore.pipeline().collection('col');\n   *\n   * p.execute().then(results => {\n   *   let field = results[0].get('a.b');\n   *   console.log(`Retrieved field value: ${field}`);\n   * });\n   * ```\n   */\n  // We deliberately use `any` in the external API to not impose type-checking\n  // on end users.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(fieldPath: string | FieldPath | Field): any {\n    if (this._fields === undefined) {\n      return undefined;\n    }\n    if (isField(fieldPath)) {\n      fieldPath = fieldPath.fieldName;\n    }\n\n    const value = this._fields.field(\n      fieldPathFromArgument('DocumentSnapshot.get', fieldPath)\n    );\n    if (value !== null) {\n      return this._userDataWriter.convertValue(value);\n    }\n  }\n}\n\n/**\n * @beta\n * Test equality of two PipelineResults.\n * @param left - First PipelineResult to compare.\n * @param right - Second PipelineResult to compare.\n */\nexport function pipelineResultEqual(\n  left: PipelineResult,\n  right: PipelineResult\n): boolean {\n  if (left === right) {\n    return true;\n  }\n\n  return (\n    isOptionalEqual(left._ref, right._ref, refEqual) &&\n    isOptionalEqual(left._fields, right._fields, (l, r) => l.isEqual(r))\n  );\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { FirestoreError, vector } from '../api';\nimport {\n  _constant,\n  AggregateFunction,\n  AliasedAggregate,\n  array,\n  constant,\n  Expression,\n  AliasedExpression,\n  field,\n  Field,\n  map,\n  Selectable\n} from '../lite-api/expressions';\nimport { VectorValue } from '../lite-api/vector_value';\n\nimport { fail } from './assert';\nimport { isPlainObject } from './input_validation';\nimport { isFirestoreValue } from './proto';\nimport { isString } from './types';\n\nexport function selectablesToMap(\n  selectables: Array<Selectable | string>\n): Map<string, Expression> {\n  const result = new Map<string, Expression>();\n  for (const selectable of selectables) {\n    let alias: string;\n    let expression: Expression;\n    if (typeof selectable === 'string') {\n      alias = selectable as string;\n      expression = field(selectable);\n    } else if (selectable instanceof Field) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else if (selectable instanceof AliasedExpression) {\n      alias = selectable.alias;\n      expression = selectable.expr;\n    } else {\n      fail(0x5319, '`selectable` has an unsupported type', { selectable });\n    }\n\n    if (result.get(alias) !== undefined) {\n      throw new FirestoreError(\n        'invalid-argument',\n        `Duplicate alias or field '${alias}'`\n      );\n    }\n\n    result.set(alias, expression);\n  }\n  return result;\n}\n\nexport function aliasedAggregateToMap(\n  aliasedAggregatees: AliasedAggregate[]\n): Map<string, AggregateFunction> {\n  return aliasedAggregatees.reduce(\n    (map: Map<string, AggregateFunction>, selectable: AliasedAggregate) => {\n      if (map.get(selectable.alias) !== undefined) {\n        throw new FirestoreError(\n          'invalid-argument',\n          `Duplicate alias or field '${selectable.alias}'`\n        );\n      }\n\n      map.set(selectable.alias, selectable.aggregate as AggregateFunction);\n      return map;\n    },\n    new Map() as Map<string, AggregateFunction>\n  );\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function vectorToExpr(\n  value: VectorValue | number[] | Expression\n): Expression {\n  if (value instanceof Expression) {\n    return value;\n  } else if (value instanceof VectorValue) {\n    const result = constant(value);\n    return result;\n  } else if (Array.isArray(value)) {\n    const result = constant(vector(value));\n    return result;\n  } else {\n    throw new Error('Unsupported value: ' + typeof value);\n  }\n}\n\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n * If the input is a string, it is assumed to be a field name, and a\n * field(value) is returned.\n *\n * @private\n * @internal\n * @param value\n */\nexport function fieldOrExpression(value: unknown): Expression {\n  if (isString(value)) {\n    const result = field(value);\n    return result;\n  } else {\n    return valueToDefaultExpr(value);\n  }\n}\n/**\n * Converts a value to an Expression, Returning either a Constant, MapFunction,\n * ArrayFunction, or the input itself (if it's already an expression).\n *\n * @private\n * @internal\n * @param value\n */\nexport function valueToDefaultExpr(value: unknown): Expression {\n  let result: Expression | undefined;\n  if (isFirestoreValue(value)) {\n    return constant(value);\n  }\n  if (value instanceof Expression) {\n    return value;\n  } else if (isPlainObject(value)) {\n    result = map(value as Record<string, unknown>);\n  } else if (value instanceof Array) {\n    result = array(value);\n  } else {\n    result = _constant(value, undefined);\n  }\n\n  return result;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Pipeline as ProtoPipeline,\n  Stage as ProtoStage\n} from '../protos/firestore_proto_api';\nimport { JsonProtoSerializer, ProtoSerializable } from '../remote/serializer';\nimport { isPlainObject } from '../util/input_validation';\nimport {\n  aliasedAggregateToMap,\n  fieldOrExpression,\n  selectablesToMap,\n  vectorToExpr\n} from '../util/pipeline_util';\nimport { isNumber, isString } from '../util/types';\n\nimport { Firestore } from './database';\nimport {\n  _mapValue,\n  AggregateFunction,\n  AliasedAggregate,\n  BooleanExpression,\n  _constant,\n  Expression,\n  Field,\n  field,\n  Ordering,\n  Selectable,\n  _field,\n  isSelectable,\n  isField,\n  isBooleanExpr,\n  isAliasedAggregate,\n  toField,\n  isOrdering,\n  isExpr\n} from './expressions';\nimport {\n  AddFields,\n  Aggregate,\n  Distinct,\n  FindNearest,\n  RawStage,\n  Limit,\n  Offset,\n  RemoveFields,\n  Replace,\n  Sample,\n  Select,\n  Sort,\n  Stage,\n  Union,\n  Unnest,\n  Where\n} from './stage';\nimport {\n  AddFieldsStageOptions,\n  AggregateStageOptions,\n  DistinctStageOptions,\n  FindNearestStageOptions,\n  LimitStageOptions,\n  OffsetStageOptions,\n  RemoveFieldsStageOptions,\n  ReplaceWithStageOptions,\n  SampleStageOptions,\n  SelectStageOptions,\n  SortStageOptions,\n  StageOptions,\n  UnionStageOptions,\n  UnnestStageOptions,\n  WhereStageOptions\n} from './stage_options';\nimport { UserDataReader, UserDataSource } from './user_data_reader';\nimport { AbstractUserDataWriter } from './user_data_writer';\n\n/**\n * @beta\n *\n * The Pipeline class provides a flexible and expressive framework for building complex data\n * transformation and query pipelines for Firestore.\n *\n * A pipeline takes data sources, such as Firestore collections or collection groups, and applies\n * a series of stages that are chained together. Each stage takes the output from the previous stage\n * (or the data source) and produces an output for the next stage (or as the final output of the\n * pipeline).\n *\n * Expressions can be used within each stage to filter and transform data through the stage.\n *\n * NOTE: The chained stages do not prescribe exactly how Firestore will execute the pipeline.\n * Instead, Firestore only guarantees that the result is the same as if the chained stages were\n * executed in order.\n *\n * Usage Examples:\n *\n * @example\n * ```typescript\n * const db: Firestore; // Assumes a valid firestore instance.\n *\n * // Example 1: Select specific fields and rename 'rating' to 'bookRating'\n * const results1 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .select(\"title\", \"author\", field(\"rating\").as(\"bookRating\")));\n *\n * // Example 2: Filter documents where 'genre' is \"Science Fiction\" and 'published' is after 1950\n * const results2 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(and(field(\"genre\").eq(\"Science Fiction\"), field(\"published\").gt(1950))));\n *\n * // Example 3: Calculate the average rating of books published after 1980\n * const results3 = await execute(db.pipeline()\n *     .collection(\"books\")\n *     .where(field(\"published\").gt(1980))\n *     .aggregate(avg(field(\"rating\")).as(\"averageRating\")));\n * ```\n */\nexport class Pipeline implements ProtoSerializable<ProtoPipeline> {\n  /**\n   * @internal\n   * @private\n   * @param _db\n   * @param userDataReader\n   * @param _userDataWriter\n   * @param stages\n   */\n  constructor(\n    /**\n     * @internal\n     * @private\n     */\n    public _db: Firestore,\n    /**\n     * @internal\n     * @private\n     */\n    private userDataReader: UserDataReader,\n    /**\n     * @internal\n     * @private\n     */\n    public _userDataWriter: AbstractUserDataWriter,\n    /**\n     * @internal\n     * @private\n     */\n    private stages: Stage[]\n  ) {}\n\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param field - The first field to add to the documents, specified as a {@link @firebase/firestore/pipelines#Selectable}.\n   * @param additionalFields - Optional additional fields to add to the documents, specified as {@link @firebase/firestore/pipelines#Selectable}s.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(field: Selectable, ...additionalFields: Selectable[]): Pipeline;\n  /**\n   * @beta\n   * Adds new fields to outputs from previous stages.\n   *\n   * This stage allows you to compute values on-the-fly based on existing data from previous\n   * stages or constants. You can use this to create new fields or overwrite existing ones (if there\n   * is name overlaps).\n   *\n   * The added fields are defined using {@link @firebase/firestore/pipelines#Selectable}s, which can be:\n   *\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#Expression}: Either a literal value (see {@link @firebase/firestore/pipelines#(constant:1)}) or a computed value\n   *   with an assigned alias using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .addFields(\n   *     field(\"rating\").as(\"bookRating\"), // Rename 'rating' to 'bookRating'\n   *     add(5, field(\"quantity\")).as(\"totalCost\")  // Calculate 'totalCost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  addFields(options: AddFieldsStageOptions): Pipeline;\n  addFields(\n    fieldOrOptions: Selectable | AddFieldsStageOptions,\n    ...additionalFields: Selectable[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let fields: Selectable[];\n    let options: {};\n    if (isSelectable(fieldOrOptions)) {\n      fields = [fieldOrOptions, ...additionalFields];\n      options = {};\n    } else {\n      ({ fields, ...options } = fieldOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const normalizedFields: Map<string, Expression> = selectablesToMap(fields);\n\n    // Create stage object\n    const stage = new AddFields(normalizedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param fieldValue - The first field to remove.\n   * @param additionalFields - Optional additional fields to remove.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(\n    fieldValue: Field | string,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Remove fields from outputs of previous stages.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection('books')\n   *   // removes field 'rating' and 'cost' from the previous stage outputs.\n   *   .removeFields(\n   *     field('rating'),\n   *     'cost'\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  removeFields(options: RemoveFieldsStageOptions): Pipeline;\n  removeFields(\n    fieldValueOrOptions: Field | string | RemoveFieldsStageOptions,\n    ...additionalFields: Array<Field | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? {}\n        : fieldValueOrOptions;\n    const fields: Array<Field | string> =\n      isField(fieldValueOrOptions) || isString(fieldValueOrOptions)\n        ? [fieldValueOrOptions, ...additionalFields]\n        : fieldValueOrOptions.fields;\n\n    // Convert user land convenience types to internal types\n    const convertedFields: Field[] = fields.map(f =>\n      isString(f) ? field(f) : (f as Field)\n    );\n\n    // Create stage object\n    const stage = new RemoveFields(convertedFields, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    stage._readUserData(\n      this.userDataReader.createContext(UserDataSource.Argument, 'removeFields')\n    );\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string` : Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param selection - The first field to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expression or string value representing the field name.\n   * @param additionalSelections - Optional additional fields to include in the output documents, specified as {@link\n   *     @firebase/firestore/pipelines#Selectable} expressions or `string` values representing field names.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(\n    selection: Selectable | string,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline;\n  /**\n   * @beta\n   * Selects or creates a set of fields from the outputs of previous stages.\n   *\n   * <p>The selected fields are defined using {@link @firebase/firestore/pipelines#Selectable} expressions, which can be:\n   *\n   * <ul>\n   *   <li>`string`: Name of an existing field</li>\n   *   <li>{@link @firebase/firestore/pipelines#Field}: References an existing field.</li>\n   *   <li>{@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name using\n   *       {@link @firebase/firestore/pipelines#Expression.(as:1)}</li>\n   * </ul>\n   *\n   * <p>If no selections are provided, the output of this stage is empty. Use {@link\n   * @firebase/firestore/pipelines#Pipeline.(addFields:1)} instead if only additions are\n   * desired.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * db.pipeline().collection(\"books\")\n   *   .select(\n   *     \"firstName\",\n   *     field(\"lastName\"),\n   *     field(\"address\").toUppercase().as(\"upperAddress\"),\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  select(options: SelectStageOptions): Pipeline;\n  select(\n    selectionOrOptions: Selectable | string | SelectStageOptions,\n    ...additionalSelections: Array<Selectable | string>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? {}\n        : selectionOrOptions;\n\n    const selections: Array<Selectable | string> =\n      isSelectable(selectionOrOptions) || isString(selectionOrOptions)\n        ? [selectionOrOptions, ...additionalSelections]\n        : selectionOrOptions.selections;\n\n    // Convert user land convenience types to internal types\n    const normalizedSelections: Map<string, Expression> =\n      selectablesToMap(selections);\n\n    // Create stage object\n    const stage = new Select(normalizedSelections, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'select'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(equal:1)}, {@link @firebase/firestore/pipelines#Expression.(lessThan:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param condition - The {@link @firebase/firestore/pipelines#BooleanExpression} to apply.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(condition: BooleanExpression): Pipeline;\n  /**\n   * @beta\n   * Filters the documents from previous stages to only include those matching the specified {@link\n   * @firebase/firestore/pipelines#BooleanExpression}.\n   *\n   * <p>This stage allows you to apply conditions to the data, similar to a \"WHERE\" clause in SQL.\n   * You can filter documents based on their field values, using implementations of {@link\n   * @firebase/firestore/pipelines#BooleanExpression}, typically including but not limited to:\n   *\n   * <ul>\n   *   <li>field comparators: {@link @firebase/firestore/pipelines#Expression.(eq:1)}, {@link @firebase/firestore/pipelines#Expression.(lt:1)} (less than), {@link\n   *       @firebase/firestore/pipelines#Expression.(greaterThan:1)}, etc.</li>\n   *   <li>logical operators: {@link @firebase/firestore/pipelines#Expression.(and:1)}, {@link @firebase/firestore/pipelines#Expression.(or:1)}, {@link @firebase/firestore/pipelines#Expression.(not:1)}, etc.</li>\n   *   <li>advanced functions: {@link @firebase/firestore/pipelines#Expression.(regexMatch:1)}, {@link\n   *       @firebase/firestore/pipelines#Expression.(arrayContains:1)}, etc.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * firestore.pipeline().collection(\"books\")\n   *   .where(\n   *     and(\n   *         gt(field(\"rating\"), 4.0),   // Filter for ratings greater than 4.0\n   *         field(\"genre\").eq(\"Science Fiction\") // Equivalent to gt(\"genre\", \"Science Fiction\")\n   *     )\n   *   );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  where(options: WhereStageOptions): Pipeline;\n  where(conditionOrOptions: BooleanExpression | WhereStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isBooleanExpr(conditionOrOptions) ? {} : conditionOrOptions;\n    const condition: BooleanExpression = isBooleanExpr(conditionOrOptions)\n      ? conditionOrOptions\n      : conditionOrOptions.condition;\n\n    // Create stage object\n    const stage = new Where(condition, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'where'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param offset - The number of documents to skip.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(offset: number): Pipeline;\n  /**\n   * @beta\n   * Skips the first `offset` number of documents from the results of previous stages.\n   *\n   * <p>This stage is useful for implementing pagination in your pipelines, allowing you to retrieve\n   * results in chunks. It is typically used in conjunction with {@link @firebase/firestore/pipelines#Pipeline.limit} to control the\n   * size of each page.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Retrieve the second page of 20 results\n   * firestore.pipeline().collection('books')\n   *     .sort(field('published').descending())\n   *     .offset(20)  // Skip the first 20 results\n   *     .limit(20);   // Take the next 20 results\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  offset(options: OffsetStageOptions): Pipeline;\n  offset(offsetOrOptions: number | OffsetStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let offset: number;\n    if (isNumber(offsetOrOptions)) {\n      options = {};\n      offset = offsetOrOptions;\n    } else {\n      options = offsetOrOptions;\n      offset = offsetOrOptions.offset;\n    }\n\n    // Create stage object\n    const stage = new Offset(offset, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'offset'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param limit - The maximum number of documents to return.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(limit: number): Pipeline;\n  /**\n   * @beta\n   * Limits the maximum number of documents returned by previous stages to `limit`.\n   *\n   * <p>This stage is particularly useful when you want to retrieve a controlled subset of data from\n   * a potentially large result set. It's often used for:\n   *\n   * <ul>\n   *   <li>**Pagination:** In combination with {@link @firebase/firestore/pipelines#Pipeline.offset} to retrieve specific pages of\n   *       results.</li>\n   *   <li>**Limiting Data Retrieval:** To prevent excessive data transfer and improve performance,\n   *       especially when dealing with large collections.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Limit the results to the top 10 highest-rated books\n   * firestore.pipeline().collection('books')\n   *     .sort(field('rating').descending())\n   *     .limit(10);\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  limit(options: LimitStageOptions): Pipeline;\n  limit(limitOrOptions: number | LimitStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(limitOrOptions) ? {} : limitOrOptions;\n    const limit: number = isNumber(limitOrOptions)\n      ? limitOrOptions\n      : limitOrOptions.limit;\n\n    // Create stage object\n    const stage = new Limit(limit, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'limit'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param group - The {@link @firebase/firestore/pipelines#Selectable} expression or field name to consider when determining\n   *     distinct value combinations.\n   * @param additionalGroups - Optional additional {@link @firebase/firestore/pipelines#Selectable} expressions to consider when determining distinct\n   *     value combinations or strings representing field names.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(\n    group: string | Selectable,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline;\n  /**\n   * @beta\n   * Returns a set of distinct values from the inputs to this stage.\n   *\n   * This stage runs through the results from previous stages to include only results with\n   * unique combinations of {@link @firebase/firestore/pipelines#Expression} values ({@link @firebase/firestore/pipelines#Field}, {@link @firebase/firestore/pipelines#AliasedExpression}, etc).\n   *\n   * The parameters to this stage are defined using {@link @firebase/firestore/pipelines#Selectable} expressions or strings:\n   *\n   * - `string`: Name of an existing field\n   * - {@link @firebase/firestore/pipelines#Field}: References an existing document field.\n   * - {@link @firebase/firestore/pipelines#AliasedExpression}: Represents the result of a function with an assigned alias name\n   *   using {@link @firebase/firestore/pipelines#Expression.(as:1)}.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Get a list of unique author names in uppercase and genre combinations.\n   * firestore.pipeline().collection(\"books\")\n   *     .distinct(toUppercase(field(\"author\")).as(\"authorName\"), field(\"genre\"), \"publishedAt\")\n   *     .select(\"authorName\");\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  distinct(options: DistinctStageOptions): Pipeline;\n  distinct(\n    groupOrOptions: string | Selectable | DistinctStageOptions,\n    ...additionalGroups: Array<string | Selectable>\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? {}\n        : groupOrOptions;\n    const groups: Array<string | Selectable> =\n      isString(groupOrOptions) || isSelectable(groupOrOptions)\n        ? [groupOrOptions, ...additionalGroups]\n        : groupOrOptions.groups;\n\n    // Convert user land convenience types to internal types\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Distinct(convertedGroups, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'distinct'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents. You define the\n   * aggregations to perform using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions which are typically results of\n   * calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating and the total number of books\n   * firestore.pipeline().collection(\"books\")\n   *     .aggregate(\n   *         field(\"rating\").avg().as(\"averageRating\"),\n   *         countAll().as(\"totalBooks\")\n   *     );\n   * ```\n   *\n   * @param accumulator - The first {@link @firebase/firestore/pipelines#AliasedAggregate}, wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @param additionalAccumulators - Optional additional {@link @firebase/firestore/pipelines#AliasedAggregate}, each wrapping an {@link @firebase/firestore/pipelines#AggregateFunction}\n   *     and providing a name for the accumulated results.\n   * @returns A new Pipeline object with this stage appended to the stage list.\n   */\n  aggregate(\n    accumulator: AliasedAggregate,\n    ...additionalAccumulators: AliasedAggregate[]\n  ): Pipeline;\n  /**\n   * @beta\n   * Performs optionally grouped aggregation operations on the documents from previous stages.\n   *\n   * <p>This stage allows you to calculate aggregate values over a set of documents, optionally\n   * grouped by one or more fields or functions. You can specify:\n   *\n   * <ul>\n   *   <li>**Grouping Fields or Functions:** One or more fields or functions to group the documents\n   *       by. For each distinct combination of values in these fields, a separate group is created.\n   *       If no grouping fields are provided, a single group containing all documents is used. Not\n   *       specifying groups is the same as putting the entire inputs into one group.</li>\n   *   <li>**Accumulators:** One or more accumulation operations to perform within each group. These\n   *       are defined using {@link @firebase/firestore/pipelines#AliasedAggregate} expressions, which are typically created by\n   *       calling {@link @firebase/firestore/pipelines#Expression.(as:1)} on {@link @firebase/firestore/pipelines#AggregateFunction} instances. Each aggregation\n   *       calculates a value (e.g., sum, average, count) based on the documents within its group.</li>\n   * </ul>\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Calculate the average rating for each genre.\n   * firestore.pipeline().collection(\"books\")\n   *   .aggregate({\n   *       accumulators: [avg(field(\"rating\")).as(\"avg_rating\")]\n   *       groups: [\"genre\"]\n   *       });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage\n   * list.\n   */\n  aggregate(options: AggregateStageOptions): Pipeline;\n  aggregate(\n    targetOrOptions: AliasedAggregate | AggregateStageOptions,\n    ...rest: AliasedAggregate[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isAliasedAggregate(targetOrOptions) ? {} : targetOrOptions;\n    const accumulators: AliasedAggregate[] = isAliasedAggregate(targetOrOptions)\n      ? [targetOrOptions, ...rest]\n      : targetOrOptions.accumulators;\n    const groups: Array<Selectable | string> = isAliasedAggregate(\n      targetOrOptions\n    )\n      ? []\n      : targetOrOptions.groups ?? [];\n\n    // Convert user land convenience types to internal types\n    const convertedAccumulators: Map<string, AggregateFunction> =\n      aliasedAggregateToMap(accumulators);\n    const convertedGroups: Map<string, Expression> = selectablesToMap(groups);\n\n    // Create stage object\n    const stage = new Aggregate(\n      convertedGroups,\n      convertedAccumulators,\n      options\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'aggregate'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a vector proximity search on the documents from the previous stage, returning the\n   * K-nearest documents based on the specified query `vectorValue` and `distanceMeasure`. The\n   * returned documents will be sorted in order from nearest to furthest from the query `vectorValue`.\n   *\n   * <p>Example:\n   *\n   * ```typescript\n   * // Find the 10 most similar books based on the book description.\n   * const bookDescription = \"Lorem ipsum...\";\n   * const queryVector: number[] = ...; // compute embedding of `bookDescription`\n   *\n   * firestore.pipeline().collection(\"books\")\n   *     .findNearest({\n   *       field: 'embedding',\n   *       vectorValue: queryVector,\n   *       distanceMeasure: 'euclidean',\n   *       limit: 10,                        // optional\n   *       distanceField: 'computedDistance' // optional\n   *     });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  findNearest(options: FindNearestStageOptions): Pipeline {\n    // Convert user land convenience types to internal types\n    const field = toField(options.field);\n    const vectorValue = vectorToExpr(options.vectorValue);\n    const distanceField = options.distanceField\n      ? toField(options.distanceField)\n      : undefined;\n    const internalOptions = {\n      distanceField,\n      limit: options.limit,\n      rawOptions: options.rawOptions\n    };\n\n    // Create stage object\n    const stage = new FindNearest(\n      vectorValue,\n      field,\n      options.distanceMeasure,\n      internalOptions\n    );\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'addFields'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param ordering - The first {@link @firebase/firestore/pipelines#Ordering} instance specifying the sorting criteria.\n   * @param additionalOrderings - Optional additional {@link @firebase/firestore/pipelines#Ordering} instances specifying the additional sorting criteria.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(ordering: Ordering, ...additionalOrderings: Ordering[]): Pipeline;\n  /**\n   * @beta\n   * Sorts the documents from previous stages based on one or more {@link @firebase/firestore/pipelines#Ordering} criteria.\n   *\n   * <p>This stage allows you to order the results of your pipeline. You can specify multiple {@link\n   * @firebase/firestore/pipelines#Ordering} instances to sort by multiple fields in ascending or descending order. If documents\n   * have the same value for a field used for sorting, the next specified ordering will be used. If\n   * all orderings result in equal comparison, the documents are considered equal and the order is\n   * unspecified.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Sort books by rating in descending order, and then by title in ascending order for books\n   * // with the same rating\n   * firestore.pipeline().collection(\"books\")\n   *     .sort(\n   *         Ordering.of(field(\"rating\")).descending(),\n   *         Ordering.of(field(\"title\"))  // Ascending order is the default\n   *     );\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sort(options: SortStageOptions): Pipeline;\n  sort(\n    orderingOrOptions: Ordering | SortStageOptions,\n    ...additionalOrderings: Ordering[]\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isOrdering(orderingOrOptions) ? {} : orderingOrOptions;\n    const orderings: Ordering[] = isOrdering(orderingOrOptions)\n      ? [orderingOrOptions, ...additionalOrderings]\n      : orderingOrOptions.orderings;\n\n    // Create stage object\n    const stage = new Sort(orderings, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sort'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a nested map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith('parents');\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param fieldName - The {@link @firebase/firestore/pipelines#Field} field containing the nested map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(fieldName: string): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param expr - An {@link @firebase/firestore/pipelines#Expression} that when returned evaluates to a map.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(expr: Expression): Pipeline;\n  /**\n   * @beta\n   * Fully overwrites all fields in a document with those coming from a map.\n   *\n   * <p>This stage allows you to emit a map value as a document. Each key of the map becomes a field\n   * on the document that contains the corresponding value.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Input.\n   * // {\n   * //  'name': 'John Doe Jr.',\n   * //  'parents': {\n   * //    'father': 'John Doe Sr.',\n   * //    'mother': 'Jane Doe'\n   * //   }\n   * // }\n   *\n   * // Emit parents as document.\n   * firestore.pipeline().collection('people').replaceWith(map({\n   *   foo: 'bar',\n   *   info: {\n   *     name: field('name')\n   *   }\n   * }));\n   *\n   * // Output\n   * // {\n   * //  'father': 'John Doe Sr.',\n   * //  'mother': 'Jane Doe'\n   * // }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  replaceWith(options: ReplaceWithStageOptions): Pipeline;\n  replaceWith(\n    valueOrOptions: Expression | string | ReplaceWithStageOptions\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    const options =\n      isString(valueOrOptions) || isExpr(valueOrOptions) ? {} : valueOrOptions;\n    const fieldNameOrExpr: string | Expression =\n      isString(valueOrOptions) || isExpr(valueOrOptions)\n        ? valueOrOptions\n        : valueOrOptions.map;\n\n    // Convert user land convenience types to internal types\n    const mapExpr = fieldOrExpression(fieldNameOrExpr);\n\n    // Create stage object\n    const stage = new Replace(mapExpr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'replaceWith'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The parameter specifies how number of\n   * documents to be returned.\n   *\n   * <p>Examples:\n   *\n   * @example\n   * ```typescript\n   * // Sample 25 books, if available.\n   * firestore.pipeline().collection('books')\n   *     .sample(25);\n   * ```\n   *\n   * @param documents - The number of documents to sample.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(documents: number): Pipeline;\n\n  /**\n   * @beta\n   * Performs a pseudo-random sampling of the documents from the previous stage.\n   *\n   * <p>This stage will filter documents pseudo-randomly. The 'options' parameter specifies how\n   * sampling will be performed. See {@link @firebase/firestore/pipelines#SampleStageOptions} for more information.\n   *\n   * @example\n   * ```typescript\n   * // Sample 10 books, if available.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ documents: 10 });\n   *\n   * // Sample 50% of books.\n   * firestore.pipeline().collection(\"books\")\n   *     .sample({ percentage: 0.5 });\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  sample(options: SampleStageOptions): Pipeline;\n  sample(documentsOrOptions: number | SampleStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    const options = isNumber(documentsOrOptions) ? {} : documentsOrOptions;\n    let rate: number;\n    let mode: 'documents' | 'percent';\n    if (isNumber(documentsOrOptions)) {\n      rate = documentsOrOptions;\n      mode = 'documents';\n    } else if (isNumber(documentsOrOptions.documents)) {\n      rate = documentsOrOptions.documents;\n      mode = 'documents';\n    } else {\n      rate = documentsOrOptions.percentage!;\n      mode = 'percent';\n    }\n\n    // Create stage object\n    const stage = new Sample(rate, mode, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'sample'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param other - The other {@link @firebase/firestore/pipelines#Pipeline} that is part of union.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(other: Pipeline): Pipeline;\n  /**\n   * @beta\n   * Performs union of all documents from two pipelines, including duplicates.\n   *\n   * <p>This stage will pass through documents from previous stage, and also pass through documents\n   * from previous stage of the `other` {@link @firebase/firestore/pipelines#Pipeline} given in parameter. The order of documents\n   * emitted from this stage is undefined.\n   *\n   * <p>Example:\n   *\n   * @example\n   * ```typescript\n   * // Emit documents from books collection and magazines collection.\n   * firestore.pipeline().collection('books')\n   *     .union(firestore.pipeline().collection('magazines'));\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  union(options: UnionStageOptions): Pipeline;\n  union(otherOrOptions: Pipeline | UnionStageOptions): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: {};\n    let otherPipeline: Pipeline;\n    if (isPipeline(otherOrOptions)) {\n      options = {};\n      otherPipeline = otherOrOptions;\n    } else {\n      ({ other: otherPipeline, ...options } = otherOrOptions);\n    }\n\n    // Create stage object\n    const stage = new Union(otherPipeline, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'union'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param selectable - A selectable expression defining the field to unnest and the alias to use for each un-nested element in the output documents.\n   * @param indexField - An optional string value specifying the field path to write the offset (starting at zero) into the array the un-nested element is from\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(selectable: Selectable, indexField?: string): Pipeline;\n  /**\n   * @beta\n   * Produces a document for each element in an input array.\n   *\n   * For each previous stage document, this stage will emit zero or more augmented documents. The\n   * input array specified by the `selectable` parameter, will emit an augmented document for each input array element. The input array element will\n   * augment the previous stage document by setting the `alias` field  with the array element value.\n   *\n   * When `selectable` evaluates to a non-array value (ex: number, null, absent), then the stage becomes a no-op for\n   * the current input document, returning it as is with the `alias` field absent.\n   *\n   * No documents are emitted when `selectable` evaluates to an empty array.\n   *\n   * Example:\n   *\n   * @example\n   * ```typescript\n   * // Input:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tags\": [ \"comedy\", \"space\", \"adventure\" ], ... }\n   *\n   * // Emit a book document for each tag of the book.\n   * firestore.pipeline().collection(\"books\")\n   *     .unnest(field(\"tags\").as('tag'), 'tagIndex');\n   *\n   * // Output:\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"comedy\", \"tagIndex\": 0, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"space\", \"tagIndex\": 1, ... }\n   * // { \"title\": \"The Hitchhiker's Guide to the Galaxy\", \"tag\": \"adventure\", \"tagIndex\": 2, ... }\n   * ```\n   *\n   * @param options - An object that specifies required and optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  unnest(options: UnnestStageOptions): Pipeline;\n  unnest(\n    selectableOrOptions: Selectable | UnnestStageOptions,\n    indexField?: string\n  ): Pipeline {\n    // Process argument union(s) from method overloads\n    let options: { indexField?: Field } & StageOptions;\n    let selectable: Selectable;\n    let indexFieldName: string | undefined;\n    if (isSelectable(selectableOrOptions)) {\n      options = {};\n      selectable = selectableOrOptions;\n      indexFieldName = indexField;\n    } else {\n      ({\n        selectable,\n        indexField: indexFieldName,\n        ...options\n      } = selectableOrOptions);\n    }\n\n    // Convert user land convenience types to internal types\n    const alias = selectable.alias;\n    const expr = selectable.expr as Expression;\n    if (isString(indexFieldName)) {\n      options.indexField = _field(indexFieldName, 'unnest');\n    }\n\n    // Create stage object\n    const stage = new Unnest(alias, expr, options);\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'unnest'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @beta\n   * Adds a raw stage to the pipeline.\n   *\n   * <p>This method provides a flexible way to extend the pipeline's functionality by adding custom\n   * stages. Each raw stage is defined by a unique `name` and a set of `params` that control its\n   * behavior.\n   *\n   * <p>Example (Assuming there is no 'where' stage available in SDK):\n   *\n   * @example\n   * ```typescript\n   * // Assume we don't have a built-in 'where' stage\n   * firestore.pipeline().collection('books')\n   *     .rawStage('where', [field('published').lt(1900)]) // Custom 'where' stage\n   *     .select('title', 'author');\n   * ```\n   *\n   * @param name - The unique name of the raw stage to add.\n   * @param params - A list of parameters to configure the raw stage's behavior.\n   * @param options - An object of key value pairs that specifies optional parameters for the stage.\n   * @returns A new {@link @firebase/firestore/pipelines#Pipeline} object with this stage appended to the stage list.\n   */\n  rawStage(\n    name: string,\n    params: unknown[],\n    options?: { [key: string]: Expression | unknown }\n  ): Pipeline {\n    // Convert user land convenience types to internal types\n    const expressionParams = params.map((value: unknown) => {\n      if (value instanceof Expression) {\n        return value;\n      } else if (value instanceof AggregateFunction) {\n        return value;\n      } else if (isPlainObject(value)) {\n        return _mapValue(value as Record<string, unknown>);\n      } else {\n        return _constant(value, 'rawStage');\n      }\n    });\n\n    // Create stage object\n    const stage = new RawStage(name, expressionParams, options ?? {});\n\n    // User data must be read in the context of the API method to\n    // provide contextual errors\n    const parseContext = this.userDataReader.createContext(\n      UserDataSource.Argument,\n      'rawStage'\n    );\n    stage._readUserData(parseContext);\n\n    // Add stage to the pipeline\n    return this._addStage(stage);\n  }\n\n  /**\n   * @internal\n   * @private\n   */\n  _toProto(jsonProtoSerializer: JsonProtoSerializer): ProtoPipeline {\n    const stages: ProtoStage[] = this.stages.map(stage =>\n      stage._toProto(jsonProtoSerializer)\n    );\n    return { stages };\n  }\n\n  private _addStage(stage: Stage): Pipeline {\n    const copy = this.stages.map(s => s);\n    copy.push(stage);\n    return this.newPipeline(\n      this._db,\n      this.userDataReader,\n      this._userDataWriter,\n      copy\n    );\n  }\n\n  /**\n   * @internal\n   * @private\n   * @param db\n   * @param userDataReader\n   * @param userDataWriter\n   * @param stages\n   * @protected\n   */\n  protected newPipeline(\n    db: Firestore,\n    userDataReader: UserDataReader,\n    userDataWriter: AbstractUserDataWriter,\n    stages: Stage[]\n  ): Pipeline {\n    return new Pipeline(db, userDataReader, userDataWriter, stages);\n  }\n}\n\nexport function isPipeline(val: unknown): val is Pipeline {\n  return val instanceof Pipeline;\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Pipeline as LitePipeline } from '../lite-api/pipeline';\nimport { Stage } from '../lite-api/stage';\nimport { UserDataReader } from '../lite-api/user_data_reader';\nimport { AbstractUserDataWriter } from '../lite-api/user_data_writer';\n\nimport { Firestore } from './database';\n\n/**\n * @beta\n */\nexport class Pipeline extends LitePipeline {\n  /**\n   * @internal\n   * @private\n   * @param db\n   * @param userDataReader\n   * @param userDataWriter\n   * @param stages\n   * @param converter\n   * @protected\n   */\n  protected newPipeline(\n    db: Firestore,\n    userDataReader: UserDataReader,\n    userDataWriter: AbstractUserDataWriter,\n    stages: Stage[]\n  ): Pipeline {\n    return new Pipeline(db, userDataReader, userDataWriter, stages);\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Pipeline } from '../api/pipeline';\nimport { firestoreClientExecutePipeline } from '../core/firestore_client';\nimport {\n  StructuredPipeline,\n  StructuredPipelineOptions\n} from '../core/structured_pipeline';\nimport { Pipeline as LitePipeline } from '../lite-api/pipeline';\nimport { PipelineResult, PipelineSnapshot } from '../lite-api/pipeline-result';\nimport { PipelineSource } from '../lite-api/pipeline-source';\nimport { PipelineExecuteOptions } from '../lite-api/pipeline_options';\nimport { Stage } from '../lite-api/stage';\nimport {\n  newUserDataReader,\n  UserDataReader,\n  UserDataSource\n} from '../lite-api/user_data_reader';\nimport { cast } from '../util/input_validation';\n\nimport { ensureFirestoreConfigured, Firestore } from './database';\nimport { DocumentReference } from './reference';\nimport { ExpUserDataWriter } from './user_data_writer';\n\ndeclare module './database' {\n  /**\n   * @beta\n   * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n   *\n   * @example\n   * ```\n   * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n   * ```\n   */\n  interface Firestore {\n    pipeline(): PipelineSource<Pipeline>;\n  }\n}\n\n/**\n * @beta\n * Executes a pipeline and returns a Promise to represent the asynchronous operation.\n *\n * The returned Promise can be used to track the progress of the pipeline execution\n * and retrieve the results (or handle any errors) asynchronously.\n *\n * The pipeline results are returned as a {@link @firebase/firestore/pipelines#PipelineSnapshot} that contains\n * a list of {@link @firebase/firestore/pipelines#PipelineResult} objects. Each {@link @firebase/firestore/pipelines#PipelineResult} typically\n * represents a single key/value map that has passed through all the\n * stages of the pipeline, however this might differ depending on the stages involved in the\n * pipeline. For example:\n *\n * <ul>\n *   <li>If there are no stages or only transformation stages, each {@link @firebase/firestore/pipelines#PipelineResult}\n *       represents a single document.</li>\n *   <li>If there is an aggregation, only a single {@link @firebase/firestore/pipelines#PipelineResult} is returned,\n *       representing the aggregated results over the entire dataset .</li>\n *   <li>If there is an aggregation stage with grouping, each {@link @firebase/firestore/pipelines#PipelineResult} represents a\n *       distinct group and its associated aggregated values.</li>\n * </ul>\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await execute(firestore.pipeline().collection(\"books\")\n *     .where(gt(field(\"rating\"), 4.5))\n *     .select(\"title\", \"author\", \"rating\"));\n *\n * const results: PipelineResults = snapshot.results;\n * ```\n *\n * @param pipeline - The pipeline to execute.\n * @returns A Promise representing the asynchronous pipeline execution.\n */\nexport function execute(pipeline: LitePipeline): Promise<PipelineSnapshot>;\n/**\n * @beta\n * Executes a pipeline and returns a Promise to represent the asynchronous operation.\n *\n * The returned Promise can be used to track the progress of the pipeline execution\n * and retrieve the results (or handle any errors) asynchronously.\n *\n * The pipeline results are returned as a {@link @firebase/firestore/pipelines#PipelineSnapshot} that contains\n * a list of {@link @firebase/firestore/pipelines#PipelineResult} objects. Each {@link @firebase/firestore/pipelines#PipelineResult} typically\n * represents a single key/value map that has passed through all the\n * stages of the pipeline, however this might differ depending on the stages involved in the\n * pipeline. For example:\n *\n * <ul>\n *   <li>If there are no stages or only transformation stages, each {@link @firebase/firestore/pipelines#PipelineResult}\n *       represents a single document.</li>\n *   <li>If there is an aggregation, only a single {@link @firebase/firestore/pipelines#PipelineResult} is returned,\n *       representing the aggregated results over the entire dataset .</li>\n *   <li>If there is an aggregation stage with grouping, each {@link @firebase/firestore/pipelines#PipelineResult} represents a\n *       distinct group and its associated aggregated values.</li>\n * </ul>\n *\n * @example\n * ```typescript\n * const snapshot: PipelineSnapshot = await execute(firestore.pipeline().collection(\"books\")\n *     .where(gt(field(\"rating\"), 4.5))\n *     .select(\"title\", \"author\", \"rating\"));\n *\n * const results: PipelineResults = snapshot.results;\n * ```\n *\n * @param options - Specifies the pipeline to execute and other options for execute.\n * @returns A Promise representing the asynchronous pipeline execution.\n */\nexport function execute(\n  options: PipelineExecuteOptions\n): Promise<PipelineSnapshot>;\nexport function execute(\n  pipelineOrOptions: LitePipeline | PipelineExecuteOptions\n): Promise<PipelineSnapshot> {\n  const options: PipelineExecuteOptions = !(\n    pipelineOrOptions instanceof LitePipeline\n  )\n    ? pipelineOrOptions\n    : {\n        pipeline: pipelineOrOptions\n      };\n\n  const { pipeline, rawOptions, ...rest } = options;\n\n  const firestore = cast(pipeline._db, Firestore);\n  const client = ensureFirestoreConfigured(firestore);\n\n  const udr = new UserDataReader(\n    firestore._databaseId,\n    /* ignoreUndefinedProperties */ true\n  );\n  const context = udr.createContext(UserDataSource.Argument, 'execute');\n\n  const structuredPipelineOptions = new StructuredPipelineOptions(\n    rest,\n    rawOptions\n  );\n  structuredPipelineOptions._readUserData(context);\n\n  const structuredPipeline: StructuredPipeline = new StructuredPipeline(\n    pipeline,\n    structuredPipelineOptions\n  );\n\n  return firestoreClientExecutePipeline(client, structuredPipeline).then(\n    result => {\n      // Get the execution time from the first result.\n      // firestoreClientExecutePipeline returns at least one PipelineStreamElement\n      // even if the returned document set is empty.\n      const executionTime =\n        result.length > 0 ? result[0].executionTime?.toTimestamp() : undefined;\n\n      const docs = result\n        // Currently ignore any response from ExecutePipeline that does\n        // not contain any document data in the `fields` property.\n        .filter(element => !!element.fields)\n        .map(\n          element =>\n            new PipelineResult(\n              pipeline._userDataWriter,\n              element.fields!,\n              element.key?.path\n                ? new DocumentReference(firestore, null, element.key)\n                : undefined,\n              element.createTime?.toTimestamp(),\n              element.updateTime?.toTimestamp()\n            )\n        );\n\n      return new PipelineSnapshot(pipeline, docs, executionTime);\n    }\n  );\n}\n\n/**\n * @beta\n * Creates and returns a new PipelineSource, which allows specifying the source stage of a {@link @firebase/firestore/pipelines#Pipeline}.\n *\n * @example\n * ```\n * let myPipeline: Pipeline = firestore.pipeline().collection('books');\n * ```\n */\n// Augment the Firestore class with the pipeline() factory method\nFirestore.prototype.pipeline = function (): PipelineSource<Pipeline> {\n  const userDataReader = newUserDataReader(this);\n  return new PipelineSource<Pipeline>(\n    this._databaseId,\n    userDataReader,\n    (stages: Stage[]) => {\n      return new Pipeline(\n        this,\n        userDataReader,\n        new ExpUserDataWriter(this),\n        stages\n      );\n    }\n  );\n};\n"],"names":["__PRIVATE_isFirestoreValue","obj","nullValue","booleanValue","integerValue","doubleValue","timestampValue","__PRIVATE_isITimestamp","seconds","nanos","stringValue","bytesValue","Uint8Array","referenceValue","geoPointValue","__PRIVATE_isILatLng","latitude","longitude","arrayValue","__PRIVATE_isIArrayValue","values","Array","isArray","mapValue","__PRIVATE_isIMapValue","fields","__PRIVATE_isPlainObject","fieldReferenceValue","functionValue","__PRIVATE_isIFunction","name","args","pipelineValue","__PRIVATE_isIPipeline","stages","__PRIVATE_valueToDefaultExpr","value","result","Expression","__PRIVATE__map","array","__PRIVATE__constant","undefined","__PRIVATE_vectorToExpr","VectorValue","constant","vector","Error","__PRIVATE_fieldOrExpression","__PRIVATE_isString","field","constructor","this","_protoValueType","add","second","FunctionExpression","asBoolean","BooleanExpression","Constant","__PRIVATE_BooleanConstant","Field","__PRIVATE_BooleanField","__PRIVATE_BooleanFunctionExpression","FirestoreError","subtract","subtrahend","multiply","divide","divisor","mod","other","equal","notEqual","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","arrayConcat","secondArray","otherArrays","__PRIVATE_exprValues","map","arrayContains","element","arrayContainsAll","__PRIVATE_normalizedExpr","__PRIVATE_ListOfExprs","arrayContainsAny","arrayReverse","arrayLength","equalAny","others","__PRIVATE_exprOthers","notEqualAny","exists","charLength","like","__PRIVATE_stringOrExpr","regexContains","regexFind","regexFindAll","regexMatch","stringContains","startsWith","endsWith","toLower","toUpper","trim","valueToTrim","push","ltrim","rtrim","type","isType","stringConcat","secondString","otherStrings","__PRIVATE_exprs","stringIndexOf","search","stringRepeat","repetitions","stringReplaceAll","find","replacement","stringReplaceOne","concat","reverse","byteLength","ceil","floor","abs","exp","mapGet","subfield","mapSet","key","moreKeyValues","mapKeys","mapValues","mapEntries","count","AggregateFunction","_create","sum","average","minimum","maximum","first","last","arrayAgg","arrayAggDistinct","countDistinct","logicalMaximum","logicalMinimum","vectorLength","cosineDistance","dotProduct","euclideanDistance","unixMicrosToTimestamp","timestampToUnixMicros","unixMillisToTimestamp","timestampToUnixMillis","unixSecondsToTimestamp","timestampToUnixSeconds","timestampAdd","unit","amount","timestampSubtract","documentId","substring","position","length","__PRIVATE_positionExpr","arrayGet","offset","isError","ifError","catchValue","isAbsent","mapRemove","__PRIVATE_stringExpr","mapMerge","secondMap","otherMaps","__PRIVATE_secondMapExpr","__PRIVATE_otherMapExprs","pow","exponent","trunc","decimalPlaces","round","collectionId","ln","sqrt","stringReverse","ifAbsent","__PRIVATE_elseValueOrExpression","join","__PRIVATE_delimeterValueOrExpression","log10","arraySum","split","delimiter","timestampTruncate","granularity","timezone","toLowerCase","ascending","descending","as","AliasedExpression","params","exprType","methodName","__PRIVATE_af","_methodName","AliasedAggregate","_toProto","serializer","p","_readUserData","context","contextWith","forEach","expr","aggregate","alias","selectable","super","expressionType","fieldPath","fieldName","canonicalString","nameOrPath","_field","__PRIVATE_DOCUMENT_KEY_NAME","__PRIVATE_documentIdFieldPath","_internalPath","__PRIVATE_fieldPathFromArgument","_fromProto","_protoValue","_","__PRIVATE_hardAssert","__PRIVATE_parseData","c","MapValue","__PRIVATE_plainObject","__PRIVATE_toMapValue","_expr","countIf","not","conditional","thenExpr","elseExpr","__PRIVATE_normalizedCatchValue","booleanExpr","tryExpr","mapExpr","firstMap","documentPath","__PRIVATE_fieldExpr","__PRIVATE_lengthExpr","left","right","__PRIVATE_normalizedLeft","__PRIVATE_normalizedRight","elements","Object","prototype","hasOwnProperty","call","__PRIVATE__array","__PRIVATE_leftExpr","__PRIVATE_rightExpr","firstArray","__PRIVATE_arrayExpr","__PRIVATE_elementExpr","xor","additionalConditions","condition","__PRIVATE_valueOrField","__PRIVATE_expressionOrFieldName","pattern","__PRIVATE_patternExpr","__PRIVATE_substringExpr","prefix","suffix","__PRIVATE_fieldNameOrExpression","__PRIVATE_fieldOrExpr","subField","countAll","__PRIVATE_expr1","__PRIVATE_expr2","timestamp","__PRIVATE_normalizedTimestamp","__PRIVATE_normalizedUnit","__PRIVATE_normalizedAmount","currentTimestamp","and","more","or","base","rand","log","elseValue","__PRIVATE_delimiterValueOrExpression","__PRIVATE_internalGranularity","Ordering","direction","__PRIVATE_toStringValue","expression","__PRIVATE_isSelectable","val","candidate","__PRIVATE_isExpr","__PRIVATE_isOrdering","__PRIVATE_isAliasedAggregate","__PRIVATE_isBooleanExpr","__PRIVATE_isField","__PRIVATE_toField","__PRIVATE_toPipelineBooleanExpr","f","__PRIVATE_FieldFilterInternal","fieldValue","toString","op","fail","__PRIVATE_CompositeFilterInternal","__PRIVATE_conditions","getFilters","slice","__PRIVATE_toPipeline","query","db","pipeline","__PRIVATE_isCollectionGroupQuery","collectionGroup","__PRIVATE_isDocumentQuery","documents","doc","path","collection","filter","filters","where","__PRIVATE_orders","__PRIVATE_queryNormalizedOrderBy","__PRIVATE_existsConditions","explicitOrderBy","order","orderings","dir","limitType","__PRIVATE_actualOrderings","__PRIVATE_reverseOrderings","o","sort","startAt","__PRIVATE_whereConditionsFromCursor","endAt","limit","bound","__PRIVATE_filterFunc","__PRIVATE_cursors","size","inclusive","__PRIVATE_i","Stage","options","optionsProto","rawOptions","knownOptions","_optionsUtil","getOptionsProto","_name","__PRIVATE_AddFields","OptionsUtil","__PRIVATE_readUserDataHelper","__PRIVATE_RemoveFields","__PRIVATE_Aggregate","groups","accumulators","__PRIVATE_Distinct","__PRIVATE_CollectionSource","forceIndex","serverName","__PRIVATE_formattedCollectionPath","__PRIVATE_CollectionGroupSource","__PRIVATE_DatabaseSource","__PRIVATE_DocumentsSource","__PRIVATE_docPaths","__PRIVATE_formattedPaths","__PRIVATE_Where","__PRIVATE_FindNearest","distanceField","vectorValue","distanceMeasure","__PRIVATE_Limit","isNaN","Infinity","toNumber","__PRIVATE_Offset","__PRIVATE_Select","selections","__PRIVATE_Sort","__PRIVATE_Sample","rate","mode","__PRIVATE_Union","__PRIVATE_toPipelineValue","__PRIVATE_Unnest","indexField","__PRIVATE_Replace","__PRIVATE_MODE","__PRIVATE_RawStage","__PRIVATE_expressionMap","__PRIVATE_isUserData","__PRIVATE_readableData","PipelineSource","databaseId","userDataReader","_createPipeline","__PRIVATE_collectionOrOptions","__PRIVATE_isCollectionReference","__PRIVATE_collectionRefOrString","_validateReference","__PRIVATE_normalizedCollection","__PRIVATE_stage","__PRIVATE_parseContext","createContext","__PRIVATE_collectionIdOrOptions","database","__PRIVATE_docsOrOptions","docs","v","DocumentReference","__PRIVATE_dr","__PRIVATE_normalizedDocs","createFrom","_query","firestore","reference","__PRIVATE_refDbId","_databaseId","isEqual","Code","INVALID_ARGUMENT","CollectionReference","projectId","PipelineSnapshot","results","executionTime","_pipeline","_executionTime","_results","PipelineResult","userDataWriter","ref","createTime","updateTime","_ref","_userDataWriter","_createTime","_updateTime","_fields","id","data","convertValue","_fieldsProto","clone","get","pipelineResultEqual","__PRIVATE_isOptionalEqual","refEqual","l","r","__PRIVATE_selectablesToMap","__PRIVATE_selectables","Map","set","Pipeline","_db","addFields","__PRIVATE_fieldOrOptions","additionalFields","__PRIVATE_normalizedFields","_addStage","removeFields","__PRIVATE_fieldValueOrOptions","__PRIVATE_convertedFields","select","__PRIVATE_selectionOrOptions","additionalSelections","__PRIVATE_normalizedSelections","__PRIVATE_conditionOrOptions","__PRIVATE_offsetOrOptions","__PRIVATE_isNumber","__PRIVATE_limitOrOptions","distinct","__PRIVATE_groupOrOptions","additionalGroups","__PRIVATE_convertedGroups","__PRIVATE_targetOrOptions","__PRIVATE_rest","__PRIVATE_convertedAccumulators","__PRIVATE_aliasedAggregateToMap","__PRIVATE_aliasedAggregatees","reduce","findNearest","__PRIVATE_internalOptions","__PRIVATE_orderingOrOptions","additionalOrderings","replaceWith","__PRIVATE_valueOrOptions","sample","__PRIVATE_documentsOrOptions","percentage","union","__PRIVATE_otherOrOptions","__PRIVATE_otherPipeline","__PRIVATE_isPipeline","unnest","__PRIVATE_selectableOrOptions","__PRIVATE_indexFieldName","rawStage","__PRIVATE_expressionParams","__PRIVATE__mapValue","jsonProtoSerializer","copy","s","newPipeline","__PRIVATE_LitePipeline","execute","__PRIVATE_pipelineOrOptions","__PRIVATE_cast","Firestore","__PRIVATE_client","ensureFirestoreConfigured","UserDataReader","__PRIVATE_structuredPipelineOptions","__PRIVATE_StructuredPipelineOptions","structuredPipeline","StructuredPipeline","__PRIVATE_firestoreClientExecutePipeline","then","toTimestamp","__PRIVATE_newUserDataReader","__PRIVATE_ExpUserDataWriter"],"mappings":"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"}